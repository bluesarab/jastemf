#summary JastEMF examples: SIPLE tutorial.

<wiki:toc max_depth="2" />

= Tutorial Introduction =

In this tutorial we will present SIPLE --- a simple imperative programming language --- and generate different SIPLE implementations, each with additional language tooling:

 * *[#JastAdd_Version JastAdd Version]:* A standard compiler implemented based on [http://jflex.de/ JFlex], [http://beaver.sourceforge.net/ Beaver] and [http://www.jastadd.org/ JastAdd].
 * *[#EMF_Version EMF Version]:* A compiler with an EMF repository implemented based on JFlex, Beaver, JastAdd and JastEMF.
 * *[#EMFText_Version EMFText Version]:* A compiler with EMF repository and an Eclipse editor with syntax highlighting, code completion and semantic property view implemented based on [http://www.emftext.org EMFText] (including [http://www.antlr.org/ ANTLR]), JastAdd and JastEMF.

Of course, our main focus is on the EMF integrated versions. The tutorial will not only describe how to generate these using JastEMF, but also how to use the semantic metamodel implementation and what its benefits are. The JastAdd version, which represents an ordinary compiler project without any reference to metamodelling and the EMF, is used for validation issues. Its SIPLE compiler and the EMF integrated one share the same JastAdd specifications for SIPLE's semantics and are compared by a [#Regression_Tests regression test suite], to show, that the integration performed by JastEMF is correct.

For all SIPLE versions the same concrete syntax is supported. Also, all SIPLE versions have the same static semantics, including a nested block structured name analysis supporting nested procedure declarations and lexic scopes (closures) and a strong type analysis. Additionally, all SIPLE versions support the interpretation of programs, whereas only the JastAdd and EMF versions support an appropriate command line interface to execute programs via invocation from command line. Last but not least, the JastAdd and EMF versions are [#Regression_Tests regression tested] to each other to validate JastEMF's correctness.

The following table summarises and forecloses the features of the different SIPLE implementations investigated in this tutorial:

|| *Version* || *Semantics (Static & Execution)* || *Standalone Interpreter* || *Tests* || *Metamodel* || *Eclipse Model Editor* || *Eclipse Text Editor* ||
|| JastAdd || Yes || Yes || Yes || No || No || No ||
|| EMF || Yes || Yes || Yes || Yes || Yes || No ||
|| EMFText || Yes || No || No || Yes || Yes || Yes ||

== A First Look on SIPLE ==

To get an impression of SIPLE, consider the following programm given in concrete syntax:
{{{
Procedure main() Begin
    Write fibunacci(10);
    Write mr(10);
End;

Procedure fibunacci(Var n:Integer):Integer Begin
    Var result:Integer;
    If (n > 1) Then
        result := fibunacci(n-1) + fibunacci(n-2);
    Else
        result := 1;
    Fi;
    Return result;
End;

Procedure mr(Var n:Integer) Begin
    Procedure mr2(Var lb:Integer, Var ub:Integer);
    
    Procedure mr1(Var lb:Integer, Var ub:Integer) Begin
        If lb >= 0 Then
            Write lb;
            mr2(lb - 1, ub);
        Fi;
    End;
    
    Procedure mr2(Var lb:Integer, Var ub:Integer) Begin
        Write ub;
        mr1(lb, ub + 1);
    End;	
    
    mr1(n, n);
End;
}}}
It consists of two procedures. The first computes the well-known [http://en.wikipedia.org/wiki/Fibonacci_number Fibunacci numbers] and the second writes, starting from a natural number, a sequence of its predecessors and successors. In the end the program prints out the Fibunacci number of `10` and the sequence `10, 10, 9, 11, 8, 12, 7, 13, 6, 14, 5, 15, 4, 16, 3, 17, 2, 18, 1, 19, 0, 20`.

= Deployment and Configuration =

== Installation ==

The SIPLE tutorial can be checked out from the project's SVN repository. It is named _"calculator"_ and a subfolder of _"jastemf-examples"_. It is recommended to check it out within Eclipse, e.g. using [http://subclipse.tigris.org/ Subclipse].

To install Subclipse use its Eclipse update site via _Help => Install new Software => Work with: "http://subclipse.tigris.org/update_1.6.x" =>_ select the required components _=> Next =>_ ... _=> Finish_. After installation, make sure that the correct SVN interface is configurated (_Window => Preferences => Team => SVN => SVN interface:_ Usually it should be the _"SVNKit (Pure Java)" => Apply => OK_).

The EMFText SIPLE version additionally requires the [http://www.emftext.org EMFText] plugin to be deployed. The required libraries are in the _"sources/applications/emftext-plugins"_ folder. Just copy them into your Eclipse's _"dropins"_ folder and restart Eclipse.

Last but not least, [http://st.inf.tu-dresden.de/rtt RTT] is used to regression test the EMF SIPLE version against the JastAdd version. RTT's `jar` distribution is already contained in and referenced by the project. However, the integration of RTT is done using [http://www.eclipse.org/aspectj/ AspectJ]. Thus, the [http://www.eclipse.org/ajdt/ AspectJ Development Tools] for Eclipse are required. Just install them via their update site _"http://download.eclipse.org/tools/ajdt/35/update"_ as described for Subclipse above.

The following table summarises the tools used by the SIPLE project, their purpose, whether they must be manually installed or configurated and if they are already contained in the project's repository:

|| *Tool* || *Purpose* || *Must be Installed* || *Shiped with SIPLE* ||
|| [http://subclipse.tigris.org/ Subclipse] || To check out the project from its SVN || Yes || No ||
|| JastEMF || To integrate JastAdd semantics into EMF metamodel implementations || [Installation Yes] || Yes ||
|| [http://www.emftext.org EMFText] || Required to generate the EMFText SIPLE version || Yes || Yes ||
|| [http://www.eclipse.org/ajdt/ AspectJ] || To weave regression test support into the JastAdd and EMF SIPLE versions || Yes || No ||
|| [http://st.inf.tu-dresden.de/rtt RTT] || Regression test tool || No || Yes ||
|| [http://beaver.sourceforge.net/ Beaver] || LALR(1) parsergenerator || No || Yes ||
|| [http://jflex.de/ JFlex] || Lexer generator || No || Yes ||

== Configuration ==

After checking out SIPLE, deploying EMFText and installing the Eclipse AspectJ tools no further configurations are required. The different SIPLE versions can be immediately generated using [http://ant.apache.org/ Ant] build scripts. It is only important to remember, that all build scripts must be executed within the JRE in which Eclipse is executed.

To execute a build script within the same JRE, select _Run => External Tools => External Tool Configurations =>_ double click _Ant Build =>_ give the script a name and select it (_Buildfile:_ e.g. `${workspace_loc:/calculator/specifications/siple/build.xml}`) _=> JRE => Run in the same JRE as the workspace => Apply_. Of course, also the desired target has to be selected under the _Targets_ tab. In SIPLE's case it is also recommended to automatically refresh and build the workspace after generation (_Refresh => The project containing the selected resource => Recoursively include sub-folders_ should be selected; _Build => The project containing the selected resource_).

Further steps, how to deploy and use generated implementations, are given in the respective version's description.

= Project Repository Overview =

Before we investigate how to generate and use the different SIPLE versions, let us take a short look on the project's structure. The project consists of four relevant resources:

 * SIPLE implementation (source code folder _"implementation"_)
 * SIPLE specifications (folder _"specifications"_)
 * SIPLE regression tests (folder _"tests"_)
 * Required libraries and other resources (folder _"sources"_)

The following screenshot gives an impression of the example's repository:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_structure.png

== Implementation ==

The actual *SIPLE implementation* is in the _"implementation"_ source code folder. Most of it will be generated as shown later. Its general package structure is as follows:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_implementation.png

 * _siple_: Contains a simple `Interpreter` class to execute SIPLE programs from command line. It expects only one argument --- the program file to interpret. Given a program to interpret the class just instantiates a SIPLE parser and lexer, which are used to produce the program's model. Afterwards, the model itself is executed by calling its execution semantics. *Note:* Command line interpretation is not supported for the EMFText version.
 * _siple.semantics.`*`_: These packages contain the generated semantic metamodel implementation and handwritten helper classes, like `State` and `Type` which represent interpreter states and SIPLE types respectively.
 * _siple.symbols_: Package containing generated artefacts for lexic analysis. *Note:* The EMFText version has no explicit lexic analysis. Its lexic and sytactic analysis are realised as separate Eclipse plugins.
 * _siple.syntax_: Package containing generated artefacts for syntactic analysis. *Note:* The EMFText version's syntactic analysis is realised as separate Eclipse plugins.
 * _jastemf.adaptation_: Package containing integration artefacts generated by JastEMF. These artefacts are not required by the implementation, i.e. they are not required at runtime. They are only stored for convenient reasons for developers interested which changes exactly JastEMF performed. Of course, only the EMF and EMFText versions are generated by JastEMF.
 * _rtt.adaptation_: Package containing artefacts required for regression testing via [http://st.inf.tu-dresden.de/rtt RTT]. Since RTT's integration depends on the generated SIPLE version, the package content is generated. *Note:* Regression testing is only supported for the JastAdd and EMF versions.

== Specifications ==

To generate the desired SIPLE implementation, of course, appropriate specifications are required. Thus, the second important project resource are *SIPLE's specifications*, which are in the _"specifications/siple"_ folder. The specifcations are grouped w.r.t. different implementation concerns. For each concern an equal named folder containing all its specifications exists:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_specifications.png

 * _model_: Specification of the SIPLE compiler's API --- i.e. its metamodel (_siple.ecore_) --- and how to generate an appropriate EMF implementation (_siple.genmodel_). Also a diagram of the metamodel is given (_siple.ecorediag_). *Note:* Only the EMF and EMFText version have an Ecore metamodel.
 * _semantics_: Specification of the SIPLE compiler's static semantics and its interpreter functionallities (dynamic/execution semantics). The semantics are separated w.r.t. SIPLE's different semantic concerns, which are name analysis, type analysis, data flow analysis, interpretation and helper methods subsumed in the access support concern. To declare all these concerns a so called compiler core is defined, which specifies the functionallity each concern must support, i.e. the compiler core declares all supported semantics whereas each concern's JastAdd specification (the _`*`.jrag_ files) specifies it.
 * _syntax_: Specification of the SIPLE compiler's parser. In the JastAdd and EMF version a LALR(1) Beaver parser is used (_parser.beaver_). The EMFText version is based on an LL(`*`) ANTLR parser, which is generated based on an EMFText concrete syntax definition (_siple.cs_) and uses a handwritten token resolver class (`ExprTYPETokenResolver.java`) to transform the strings `Boolean`, `Integer` and `Real` into their respective SIPLE types (`siple.semantics.Type`).
 * _symbols_: Specification of the SIPLE compiler's lexer (_lexer.jflex_). *Note:* Only the JastAdd and EMF version require an explicit lexer specification.

The generation process of a SIPLE version from its respective specifications is steered by a single [http://ant.apache.org/ Ant] build script (_"build.xml"_). Each SIPLE version can be generated using a equal named task. To clean up generated artefacts the `Clean` task can be used. *Important:* The build script must be executed within the JRE in which Eclipse is executed (For details see [#Configuration above]).

== Tests ==

Another important project resource are test programs that check SIPLE's implementation, especially the correctness of its static semantics. All artefacts related to testing are contained in the _"tests"_ folder, which consists of three subfolders:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_tests.png

 * _adaptation_: Contains AspectJ aspects, that prepare the JastAdd and EMF version's implementation for regression tests with RTT. The respective adaptation aspects are copied verbatim into the `rtt.adaptation` package while generating a concrete SIPLE version.
 * _source`_`code`_`examples_: Contains example SIPLE programs used for testing. The programs are classified, whether they are correct or contain static semantic errors. Each program (i.e. testcase) tests a certain aspect of the SIPLE language. All example programs are packed together into a single RTT testsuite.
 * _testsuites_: Contains the RTT testsuite against which the JastAdd and EMF versions are regression tested.

Similar to the generation of a SIPLE implementation from its specifications, also the generation, updating and execution of SIPLE's RTT testsuite is steered by a single Ant build script (_"build.xml"_ in the _"tests"_ directory). Again, the build script must be executed within the JRE in which Eclipse is executed (For details see [#Configuration above]).

== Libraries and other Resources ==

The last important project resource are third party libraries SIPLE depends and which are shipped with it (For a summary of each library's purpose see the table [#Installation above]). They are contained in sub folders of the _"sources"_ directory:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_sources.png

 * _libraries_: Contains `jar` libraries explicitely called by SIPLE's Ant build scripts or on which SIPLE's implementation depends on.
 * _applications_: Contains third party applications that have to be installed manually as described [#Installation above]. If for any of the _libraries_ folder's `jar` a more comprehensive end user distribution exists, also it is contained.
 * _support_: Contains support artefacts, that ease the development of SIPLE and SIPLE programs in third party tools (e.g. [http://www.textpad.com/ TextPad] syntax highlighting specifications).

= JastAdd Version =

== Introduction ==

The first SIPLE implementation we investigate has a straightforward compiler construction approach. It consist of a generated lexer, a generated LALR(1) parser, a generated attributed abstract syntax tree (AST) and a generated attribute evaluator. The attribute evaluator is part of the AST --- i.e. the AST implementation contains the semantics implementation. The lexer is specified by a single [http://jflex.de/ JFlex] specification (_"specifications/siple/symbols/lexer.jflex"_), the parser by a single [http://beaver.sourceforge.net/ Beaver] specification (_"specifcations/siple/syntax/parser.beaver"_) and the AST by several [http://www.jastadd.org/ JastAdd] AST and `jrag` specifications (_"specifications/siple/semantics/_`*`_"_). As known from compiler construction, it is the lexer's purpose to transform a stream of characters (an input program) into a stream of tokens, it is the parser's purpose to transform the stream of tokens into an AST and it is the attribute evaluator's purpose to evaluate the AST's semantics. In the following our focus is on semantics, since their JastAdd specifications are the same for all SIPLE versions, whether they have an Ecore metamodel and are EMF integrated or not.

As mentioned before, the semantics are part of the AST generated by JastAdd. For each specified AST node type a equal named class is generated --- i.e. the AST implementation is an object oriented class hierarchy --- and each attribute becomes a method of the class representing the node type it is associated with. If an attribute's method is called, its semantics are evaluated. Thus, JastAdd generates demand driven RAG evaluators and the compiler's API are the AST classes and their attribute methods. Besides attributes for static semantics, also methods for interpretation purpose are specified for SIPLE and woven by JastAdd into the AST. These methods are based on the specified static semantics and are part of the semantic specifications. Thus, interpretation is not done on a special intermediate representation, but rather on the AST. In contrast, e.g. to Java and the JVM, where the JVM interprets bytecode programs and not Java source code programs, SIPLE's interpreter is executed on the source code's AST. Therefore, it is no problem to instantiate its lexer and parser, let them construct a program's AST and just invoke the AST root node's `Interpretation` attribute to execute the program. A default implementation performing exactly these steps is the `siple.Interpreter` class's `main` method, which expects as argument the path of the program to interpret.

== Compiler API: A Quick Look on JastAdd AST and `jrag` Specifications ==

Before we generate and execute the JastAdd SIPLE version, let us have a short look on the specification of its semantics. As sketched above, to specify semantics we use JastAdd RAGs. Thus, semantics are realised by synthesized, inherited and collection attributes. The AST these attributes are associated with is given by a JastAdd AST specification (_"specifications/siple/semantics/ast.ast"_). The following is an excerpt of it:

{{{
CompilationUnit ::= Declaration*;

abstract Statement;
    
    If:Statement ::= Condition:Expression Body:Block [Alternative:Block];
    Block:Statement ::= Statement*;
    
    abstract Declaration:Statement ::= <Name:String>;
        
        ProcedureDeclaration:Declaration ::=
                Parameter:VariableDeclaration*
                <ReturnType:Type>
                Body:Block;
        VariableDeclaration:Declaration ::=
                <DeclaredType:Type>;
    
    abstract Expression:Statement;    
    
    ...
}}}

It specifies, that:

 * A `CompilationUnit` node type has arbitrary many `Declaration` child nodes.
 * `Statement` and `Expression` are abstract node types. Statements and expressions as such do not exist; only specific kinds of statements and expressions exist. Also, in SIPLE every expression is a statement.
 * `If` is a `Statement` with an `Expression` child named _Condition_, a `Block` child named _Body_ and an optional `Block` child named _Alternative_.
 * `Block` is a `Statement` that has arbitrary many `Statement` child nodes.
 * `Declaration` is an abstract node type that is a `Statement`. Every `Declaration` has a terminal child named _Name_ of type `String`.
 * `ProcedureDeclaration` and `VariableDeclaration` are special `Declaration` types. Thus, both have a _Name_.

The following diagram summarises the class hierarchy JastAdd generates for the AST specification excerpt:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/jastadd_ast_spec.png

As can be seen, besides the raw classes, also AST construction, manipulation and traversal methods are generated. They are an important part of the compiler's API besides the attribute methods woven into the AST classes (For convenient reasons the methods of the attributes discussed in the following are not shown in the class-diagram).

== Generation ==

To generate the JastAdd version's implementation just open the _"specifications/siple/build.xml"_ Ant script, configure it to be executed within Eclipse's JRE as described [#Configuration above] and execute the _"JastAdd Version"_ task. After generation the project should be error free (If there are errors remaining, ensure you [#Deployment_and_Configuration installed and configurated] everything correctly). If everything performed well the console output should look like below:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/console_buildprocess_jastadd_version.png

== Application: Interpretation of SIPLE Programs via Command Line ==

To test the just generated implementation you can on the one hand execute the regression tests as described [#Regression_Tests later], investigate the regression test's expected results to see each attribute's value --- i.e. browse the compiler internal semantics --- or execute the SIPLE interpreter. For now we will focus on the interpreter. The EMF integrated versions are much better suited to browse compiler internal semantics.

Assume you have the following SIPLE program saved in a file (e.g. in _"tests/source_`_`_code_`_`_examples/test.expr"_):

{{{
Procedure main() Begin
    Write fac(12);
End;

Procedure fac(Var n:Integer):Integer Begin
    If n = 0 Then
        Return 1;
    Fi;
    Return n * fac(n - 1);
End;
}}}

To execute it open the `siple.Interpreter` class. Select _Run => Run Configurations =>_ double click _Java Application =>_ select a name, e.g. `Interpreter` _=> Arguments => Program arguments:_ `"path/to/calculator/tests/source_code_examples/test.expr"` _=> Apply => Run_. As expected, the `Write` statement on line 2 prints the faculty of 12, i.e. `479001600`.

Let us introduce some error into the program, e.g. a reference to an undeclared variable `a` in the recursive `fac` method invocation:

{{{
Procedure main() Begin
    Write fac(12);
End;

Procedure fac(Var n:Integer):Integer Begin
    If n = 0 Then
        Return 1;
    Fi;
    Return n * fac(a - 1);
End;
}}}

Of course, the interpretation fails. After all the program is erroneous. But it does not fail randomly. It fails with a `siple.semantics.InterpretationException`:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/console_interpretation_exception.png

Let us keep the error, but additionally change the `fac(12)` procedure invocation to `fac(0)`:

{{{
Procedure main() Begin
    Write fac(0);
End;

Procedure fac(Var n:Integer):Integer Begin
    If n = 0 Then
        Return 1;
    Fi;
    Return n * fac(a - 1);
End;
}}}

If executed, the program now succeeds and prints `1`. That might look strange. After all the program still is erroneous. But it makes sense if you remember, that we are doing a source code interpretation. And of course, the recursive `fac` invocation is never encountered throughout interpretation for n = 0. Thus, the static semantics of a program construct are only computed while interpretation, if the construct is encountered. One might conclude, that this is a very inefficient solution, since program constructs that are executed several times always must be semantically evaluated. But that is not a necessity, since attribute values can be cached in JastAdd using the `lazy` attribute modifier.

== Conclusion ==

Even if we did not investigate the RAG specifications of SIPLE's semantics, the so far described implementation should have made clear, that RAGs are a very well-suited and known approach to specify semantics. The interested reader might have already browsed SIPLE's semantic specifications and recognized, that:

 * Semantics can be nicely decomposed into different concerns (Called aspects in JastAdd)
 * It is no problem to monotonic extend languages, i.e. to add further language constructs' semantics as modules. Thus, RAGs permit the specification-driven development of extensible compilers (E.g. see Tobj√∂rn Ekmans PhD. thesis _"Extensible Compiler Construction"_ which describes the implementation of a Java compiler using JastAdd).
 * The complicated part of semantics --- the distribution of local information w.r.t. certain constraints accross a structure, to combine such information and further redistribute the results --- can be very convenient specified using RAGs. In essence attribute equations are specified w.r.t. a local --- i.e. easy to understand --- context and resulting complicated tree traversals and dependencies are automatically handled by the evaluator, such that there is no need to worry about traversal and dependency strategies (It is the manual implementation/specification of such traversal and dependency strategies that make semantics complicated. And many approaches that do not scale and only fit for toy examples do so because of this issue.).

So, from a compiler developers viewpoint (to conveniently implement a reliable, easy maintainable and extensible/changeable compiler) the JastAdd SIPLE version is fine. However, from a tool developers and metamodelers viewpoint, who is interested to integrate SIPLE into existing environments and likes to provide a convenient tool API and repository, the just presented solution is not so well. Its main problem is the proprietary API (AST and `jrag` specifications) and repository.

In the next section we present the EMF version, which improves in that direction. It has the same semantics as the just presented JastAdd version and additionally an Ecore metamodel, which defines its API.

= EMF Version =

== Introduction ==

== Generation ==

== Application: Editing SIPLE Programs as Models via generated Eclipse Model Editors ==

== Conclusion ==

= EMFText Version =

== Introduction ==

== Generation ==

== Application: Editing SIPLE Programs as Models in a generated Eclipse Text Editor ==

== Conclusion ==

= Regression Tests =

SIPLE's different language constructs are systematically tested.

= Summary =