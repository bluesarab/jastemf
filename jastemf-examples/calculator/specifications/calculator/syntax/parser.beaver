/**
 * <copyright>
 *
 * This program and the accompanying materials are made available under the
 * terms of the BSD 3-clause license which accompanies this distribution.
 *
 * </copyright>
 */

/*
 * @author C. BÃ¼rger
 */
%package "calculator.syntax";
%import "calculator.semantics.ast.*","calculator.semantics.Type";

%class "CalculatorParser";

// Var, Begin, End
%terminals kVAR, kBEGIN, kEND;
// If, Then, Else, Fi
%terminals kIF, kTHEN, kELSE, kFI;
// While, Do, Od
%terminals kWHILE, kDO, kOD;
// Boolean, Integer, Real
%terminals kBOOLEAN, kINTEGER, kREAL;
// Not, And, Or
%terminals kNOT, kAND, kOR;
// *, +, -, /
%terminals pSTAR, pPLUS, pMINUS, pSLASH;
// =, #, <=, >=, <, >
%terminals pEQUALS, pSHARP, pANGLEBRACKETLEFT_EQUALS,
	pANGLEBRACKETRIGHT_EQUALS, pANGLEBRACKETLEFT, pANGLEBRACKETRIGHT;
// (, )
%terminals pBRACKETOPENROUND, pBRACKETCLOSEROUND;
// :, ;, ,
%terminals pCOLON, pSEMICOLON, pCOMMA;
%terminals IDENTIFIER, CONSTANT;

%goal CompilationUnit;

%typeof IDENTIFIER = "String";
%typeof CONSTANT = "String";

%typeof CompilationUnit = "CompilationUnit";
%typeof Declaration = "Declaration";
%typeof ProcedureDeclaration = "ProcedureDeclaration";
%typeof VariableDeclaration = "VariableDeclaration";
%typeof Block = "Block";
%typeof Statement = "Statement";
%typeof Expression = "Expression";
%typeof OrExpr = "Expression";
%typeof AndExpr = "Expression";
%typeof EqExpr = "Expression";
%typeof AddExpr = "Expression";
%typeof MulExpr = "Expression";
%typeof UnaryExpr = "Expression";
%typeof PrimExpr = "Expression";
%typeof Type = "Type";
%typeof DeclarationList = "List<Declaration>";
%typeof ParameterList = "List<VariableDeclaration>";
%typeof StatementList = "List<Statement>";
%typeof ArgumentList = "List<Expression>";

CompilationUnit = DeclarationList.decls
	{:
		return new Symbol(new CompilationUnit(decls));
	:}
	;

DeclarationList = Declaration.decl
	{:
		return new Symbol(new List<Declaration>().add(decl));
	:}
	| DeclarationList.list Declaration.decl
	{:
		list.add(decl);
		return _symbol_list;
	:}
	;

Declaration = VariableDeclaration
	| ProcedureDeclaration
	;

VariableDeclaration = kVAR IDENTIFIER.id pCOLON Type.type
	{:
		return new Symbol(new VariableDeclaration(id, type));
	:}
	;

ProcedureDeclaration = kPROCEDURE IDENTIFIER.id pBRACKETOPENROUND ParameterList.paras pBRACKETCLOSEROUND pCOLON Type.returnType Block.body
	{:
		return new Symbol(new ProcedureDeclaration(id, paras, returnType, body));
	:}
	| kPROCEDURE IDENTIFIER.id pBRACKETOPENROUND ParameterList.paras pBRACKETCLOSEROUND Block.body
	{:
		return new Symbol(new ProcedureDeclaration(id, paras, Type.Undefined, body));
	:}
	;

ParameterList = VariableDeclaration.decl
	{:
		return new Symbol(new List<Declaration>());
	:}
	| ParameterList.list pCOMMA VariableDeclaration.decl
	{:
		list.add(decl);
		return _symbol_list;
	:}
	;

Block = kBEGIN StatementList.list kEND
	{: 
		return new Symbol(new Block(list));
	:}
	;

StatementList =
	{:
		return new Symbol(new List<Statement>());
	:}
	| StatementList.list Statement.stmt pSEMICOLON
	{:
		list.add(stmt);
		return _symbol_list;
	:}
	;

Statement = Declaration
	| Block
	| kIF Expression.cond kTHEN StatementList.body kELSE StatementList.alternative kFI
	{:
		return new Symbol(new If(cond, new Block(body), new Opt(new Block(alternative))));
	:}
	| kIF Expression.cond kTHEN StatementList.body kFI
	{:
		return new Symbol(new If(cond, new Block(body), new Opt()));
	:}
	| kWHILE Expression.cond kDO StatementList.body kOD
	{:
		return new Symbol(new While(cond, new Block(body)));
	:}
	| IDENTIFIER.id pCOLON_EQUALS Expression.expr
	{:
		return new Symbol(new VariableAssignment(id, expr));
	:}
	| kRETURN Expression.expr
	{:
		return new Symbol(new ProcedureReturn(new Opt(expr)));
	:}
	| kRETURN
	{:
		return new Symbol(new ProcedureReturn(new Opt()));
	:}
	| Expression
	;

Expression = OrExpr
	;

OrExpr = OrExpr.expr1 pLINEVERTICAL_LINEVERTICAL AndExpr.expr2
	{:
		return new Symbol(new Or(expr1, expr2));
	:}
	| AndExpr
	;

AndExpr = AndExpr.expr1 pAND_AND EqExpr.expr2
	{:
		return new Symbol(new And(expr1, expr2));
	:}
	| EqExpr
	;

EqExpr = EqExpr.expr1 pEQUALS_EQUALS RelExpr.expr2
	{:
		return new Symbol(new Equal(expr1, expr2));
	:}
	| RelExpr
	;

RelExpr = RelExpr.expr1 pANGLEBRACKETRIGHT AddExpr.expr2
	{:
		return new Symbol(new GreaterThan(expr1, expr2));
	:}
	| RelExpr.expr1 pANGLEBRACKETLEFT AddExpr.expr2
	{:
		// A < B iff Not (A > B) And Not (A = B)
		return new Symbol(new And(
			new Not(new GreaterThan(expr1, expr2)),
			new Not(new Equal(expr1.fullCopy(), expr2.fullCopy()))));
	:}
	| RelExpr.expr1 pANGLEBRACKETRIGHT_EQUALS AddExpr.expr2
	{:
		// A >= B iff A > B Or A = B
		return new Symbol(new Or(
			new GreaterThan(expr1, expr2),
			new Equal(expr1.fullCopy(), expr2.fullCopy())));
	:}
	| RelExpr.expr1 pANGLEBRACKETLEFT_EQUALS AddExpr.expr2
	{:
		// A <= B iff Not (A > B)
		return new Symbol(new Not(new GreaterThan(expr1, expr2)));
	:}
	| AddExpr
	;

AddExpr = AddExpr.expr1 pPLUS MulExpr.expr2
	{:
		return new Symbol(new Addition(expr1, expr2));
	:}
	| AddExpr.expr1 pMINUS MulExpr.expr2
	{:
		return new Symbol(new Subtraction(expr1, expr2));
	:}
	| MulExpr
	;

MulExpr = MulExpr.expr1 pSTAR UnaryExpr.expr2
	{:
		return new Symbol(new Multiplication(expr1, expr2));
	:}
	| MulExpr.expr1 pSLASH UnaryExpr.expr2
	{:
		return new Symbol(new Division(expr1, expr2));
	:}
	| UnaryExpr
	;

UnaryExpr = pMINUS PrimExpr.expr
	{:
		return new Symbol(new UMinus(expr));
	:}
	| pEXCLAMATIONMARK PrimExpr.expr
	{:
		return new Symbol(new Not(expr));
	:}
	| PrimExpr
	;

PrimExpr = CONSTANT.co
	{:
		return new Symbol(new Constant(co));
	:}
	| IDENTIFIER.id
	{:
		return new Symbol(new Reference(id));
	:}
	| IDENTIFIER.id pBRACKETOPENROUND ArgumentList.list pBRACKETCLOSEROUND
	{:
		return new Symbol(new ProcedureCall(id, list));
	:}
	| pBRACKETOPENROUND Expression.expr pBRACKETCLOSEROUND
	{:
		return new Symbol(new NestedExpression(expr));
	:}
	;

ArgumentList =
	{:
		return new List<Expression>();
	:}
	| ExpressionList.list pCOMMA Expression.expr
	{:
		list.add(expr);
		return _symbol_list;
	:}
	;
	
Type = kINT.type {: return new Symbol(Type.Integer); :}
	| kFLOAT.type {: return new Symbol(Type.Real); :}
	| kBOOL.type {: return new Symbol(Type.Boolean); :}
	;
