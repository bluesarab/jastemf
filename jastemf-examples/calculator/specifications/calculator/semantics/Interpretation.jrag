/**
 * <copyright>
 *
 * This program and the accompanying materials are made available under the
 * terms of the BSD 3-clause license which accompanies this distribution.
 *
 * </copyright>
 */

/**
 * @author C. BÃ¼rger
 */
aspect Interpretation {
	/** Constant Evaluation */
	
	/*
	syn SortedSet<Statement> Expression.RequiredComputations() {
		SortedSet<Statement> result = new TreeSet<Statement>();
		
	}
	*/
	
	eq Expression.ConstantValue() { // TODO:
		/*
		Collections.sort(
				toInterpret,
				new Comparator<Statement>() {
					public int compare(Statement o1, Statement o2) {
						return o2.NodeAddress().compareTo(o1.NodeAddress());
					}
				});
		*/
		
		/*
		if (MaybeUndecidable())
			return null;
		State vm = new State();
		for (Statement instr:RequiredComputations()) {
			if (instr.MaybeUndecidable())
				return null;
			instr.Interpret(vm);
		}
		return Value(vm);
		*/
		return null;
	}
	
	/** Expression Evaluation */
	
	public Object Constant.Value(State vm) {
		switch (Type()) {
		case Boolean: return AsBoolean();
		case Integer: return AsInteger();
		case Real: return AsReal();
		default: throw new InterpretationException();
		}
	}
	public Object Reference.Value(State vm) {
		if (Type() != Type.ERROR_TYPE)
			return vm.lookUpValue(Declaration());
		throw new InterpretationException();
	}
	public Object ProcedureCall.Value(State vm) {
		if (Type() == Type.ERROR_TYPE)
			throw new InterpretationException();
		Object[] args = new Object[getNumArgument()];
		for (int i = 0; i < args.length; i++)
			args[i] = getArgument(i).Value(vm);
		vm.newFrame();
		for (int i = 0; i < args.length; i++)
			vm.allocateVariable(
					Declaration().getParameter(i),
					args[i]);
		Declaration().getBody().Interpret(vm);
		Object value = null;
		if (Type() != Type.Undefined)
			value = vm.getReturnValue();
		vm.deleteFrame();
		return value;
	}
	public Object NestedExpression.Value(State vm) {
		return getExpression().Value(vm);
	}
	public Object Not.Value(State vm) {
		if (Type() == Type.Boolean)
			return !(Boolean)getOperand().Value(vm);
		throw new InterpretationException();
	}
	public Object UMinus.Value(State vm) {
		if (Type() == Type.Real)
			return -(Float)getOperand().Value(vm);
		if (Type() == Type.Integer)
			return -(Integer)getOperand().Value(vm);
		throw new InterpretationException();
	}
	public Object And.Value(State vm) {
		if (Type() == Type.Boolean)
			return (Boolean)getOperand1().Value(vm) && (Boolean)getOperand2().Value(vm);
		throw new InterpretationException();
	}
	public Object Or.Value(State vm) {
		if (Type() == Type.Boolean)
			return (Boolean)getOperand1().Value(vm) || (Boolean)getOperand2().Value(vm);
		throw new InterpretationException();
	}
	public Object Equal.Value(State vm) {
		if (Type() != Type.Boolean)
			throw new InterpretationException();
		if (getOperand1().Type() == Type.Boolean)
			return (Boolean)getOperand1().Value(vm) ==
				(Boolean)getOperand2().Value(vm);
		if (getOperand1().Type() == Type.Integer && getOperand2().Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) ==
				(Integer)getOperand2().Value(vm);
		return ((Number)getOperand1().Value(vm)).floatValue() ==
			((Number)getOperand2().Value(vm)).floatValue();
	}
	public Object GreaterThan.Value(State vm) {
		if (Type() != Type.Boolean)
			throw new InterpretationException();
		if (getOperand1().Type() == Type.Integer && getOperand2().Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) >
				(Integer)getOperand2().Value(vm);
		return ((Number)getOperand1().Value(vm)).floatValue() >
			((Number)getOperand2().Value(vm)).floatValue();
	}
	public Object Addition.Value(State vm) {
		if (Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) +
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real)
			return ((Number)getOperand1().Value(vm)).floatValue() +
				((Number)getOperand2().Value(vm)).floatValue();
		throw new InterpretationException();
	}
	public Object Subtraction.Value(State vm) {
		if (Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) -
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real)
			return ((Number)getOperand1().Value(vm)).floatValue() -
				((Number)getOperand2().Value(vm)).floatValue();
		throw new InterpretationException();
	}
	public Object Multiplication.Value(State vm) {
		if (Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) *
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real)
			return ((Number)getOperand1().Value(vm)).floatValue() *
				((Number)getOperand2().Value(vm)).floatValue();
		throw new InterpretationException();
	}
	public Object Division.Value(State vm) {
		if (Type() == Type.Integer)
			if ((Integer)getOperand2().Value(vm) != 0)
				return (Integer)getOperand1().Value(vm) /
					(Integer)getOperand2().Value(vm);
			else throw new InterpretationException("Devision by zero.");
		if (Type() == Type.Real)
			if (((Number)getOperand2().Value(vm)).floatValue() != 0)
				return ((Number)getOperand1().Value(vm)).floatValue() /
					((Number)getOperand2().Value(vm)).floatValue();
			else throw new InterpretationException("Devision by zero.");
		throw new InterpretationException();
	}
	
	/** Program Interpretation */
	
	eq CompilationUnit.Interpret() {
		if (MainProcedure() == null)
			throw new InterpretationException();
		State vm = new State();
		// Allocate all global variables:
		for (int i = 0; i < getNumDeclaration(); i++)
			getDeclaration(i).Interpret(vm);
		// Execute the main function:
		vm.newFrame();
		MainProcedure().getBody().Interpret(vm);
		vm.deleteFrame();
		return vm;
	}
	
	public void ProcedureDeclaration.Interpret(State vm) {
		if (LookUpPDecl(getName()).size() >= 2)
			throw new InterpretationException();
	}
	public void VariableDeclaration.Interpret(State vm) {
		if (LookUpVDecl(getName()).size() >= 2)
			throw new InterpretationException();
		switch (Type()) {
		case Boolean: vm.allocateVariable(this, false); break;
		case Integer: vm.allocateVariable(this, 0); break;
		case Real: vm.allocateVariable(this, 0.0); break;
		}
	}
	public void Block.Interpret(State vm) {
		for (int i = 0; i < getNumStatement(); i++) {
			getStatement(i).Interpret(vm);
			if (vm.getReturnValue() != null)
				return;
		}
	}
	public void If.Interpret(State vm) {
		if (getCondition().Type() != Type.Boolean)
			throw new InterpretationException();
		if ((Boolean)getCondition().Value(vm))
			getBody().Interpret(vm);
		else if (hasAlternative())
			getAlternative().Interpret(vm);
	}
	public void While.Interpret(State vm) {
		if (getCondition().Type() != Type.Boolean)
			throw new InterpretationException();
		while ((Boolean)getCondition().Value(vm)) {
			getBody().Interpret(vm);
			if (vm.getReturnValue() != null)
				return;
		}
	}
	public void VariableAssignment.Interpret(State vm) {
		if (Type() == Type.ERROR_TYPE)
			throw new InterpretationException();
		vm.setValue(Declaration(), getRValue().Value(vm));
	}
	public void ProcedureReturn.Interpret(State vm) {
		if (Type() == Type.ERROR_TYPE)
			throw new InterpretationException();
		if (hasExpression())
			vm.setReturnValue(getExpression().Value(vm));
		else vm.setReturnValue(Type.Undefined);
	}
	public void Write.Interpret(State vm) {
		if (getExpression().Type() == Type.ERROR_TYPE)
			throw new InterpretationException();
		vm.getStdOut().append(getExpression().Value(vm));
		vm.getStdOut().append("\n");
	}
	public void Expression.Interpret(State vm) {
		Value(vm); /* May contain procedure calls with side effects. */
	}
}
