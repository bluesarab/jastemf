/**
 * <copyright>
 *
 * This program and the accompanying materials are made available under the
 * terms of the BSD 3-clause license which accompanies this distribution.
 *
 * </copyright>
 */

/**
 * @author C. BÃ¼rger
 */
aspect Interpretation {
	/** Constant Evaluation */
	
	syn SortedSet<Statement> Expression.RequiredComputations() {
		SortedSet<Statement> result = new TreeSet<Statement>();
		
	}
	
	eq Expression.ConstantValue() {
		/*
		Collections.sort(
				toInterpret,
				new Comparator<Statement>() {
					public int compare(Statement o1, Statement o2) {
						return o2.NodeAddress().compareTo(o1.NodeAddress());
					}
				});
		*/
		if (MaybeUndecidable())
			return null;
		State vm = new State();
		for (Statement instr:RequiredComputations()) {
			if (instr.MaybeUndecidable())
				return null;
			instr.Interpret(vm);
		}
		return Value(vm);
	}
	
	/** Expression Evaluation */
	
	eq Constant.Value(State vm) {
		if (Type() == Type.Boolean)
			return AsBoolean();
		if (Type() == Type.Integer)
			return AsInteger();
		return AsReal();
	}
	eq Reference.Value(State vm) = vm.lookUpValue(Declaration()) != null ?
			vm.lookUpValue(Declaration()) :
			new ErrorValue();
	eq ProcedureCall.Value(State vm) {
		vm.newFrame();
		Declaration().getBody().Interpret(vm);
		final Object value;
		if (Type() != Type.Undefined && Type() != Type.ERROR_TYPE)
			value = vm.getReturnValue();
		else value = new ErrorValue();
		vm.deleteFrame();
		return value;
	}
	eq NestedExpression.Value(State vm) = getExpression().Value(vm);
	eq Not.Value(State vm) = Type() == Type.Boolean ?
			!(Boolean)getOperand().Value(vm) :
			new ErrorValue();
	eq UMinus.Value(State vm) {
		if (Type() == Type.Real)
			return -(Float)getOperand().Value(vm);
		if (Type() == Type.Integer)
			return -(Integer)getOperand().Value(vm);
		return new ErrorValue();
	}
	eq And.Value(State vm) = Type() == Type.Boolean ?
			(Boolean)getOperand1().Value(vm) && (Boolean)getOperand2().Value(vm) :
			new ErrorValue();
	eq Or.Value(State vm) = Type() == Type.Boolean ?
			(Boolean)getOperand1().Value(vm) || (Boolean)getOperand2().Value(vm) :
			new ErrorValue();
	eq Equal.Value(State vm) {
		if (Type() != Type.Boolean)
			return new ErrorValue();
		if (getOperand1().Type() == Type.Boolean)
			return (Boolean)getOperand1().Value(vm) ==
				(Boolean)getOperand2().Value(vm);
		if (getOperand1().Type() == Type.Integer && getOperand2().Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) ==
				(Integer)getOperand2().Value(vm);
		return ((Number)getOperand1().Value(vm)).floatValue() ==
			((Number)getOperand2().Value(vm)).floatValue();
	}
	eq GreaterThan.Value(State vm) {
		if (Type() != Type.Boolean)
			return new ErrorValue();
		if (getOperand1().Type() == Type.Integer && getOperand2().Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) >
				(Integer)getOperand2().Value(vm);
		return ((Number)getOperand1().Value(vm)).floatValue() >
			((Number)getOperand2().Value(vm)).floatValue();
	}
	eq Addition.Value(State vm) {
		if (Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) +
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real)
			return ((Number)getOperand1().Value(vm)).floatValue() +
				((Number)getOperand2().Value(vm)).floatValue();
		return new ErrorValue();
	}
	eq Subtraction.Value(State vm) {
		if (Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) -
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real)
			return ((Number)getOperand1().Value(vm)).floatValue() -
				((Number)getOperand2().Value(vm)).floatValue();
		return new ErrorValue();
	}
	eq Multiplication.Value(State vm) {
		if (Type() == Type.Integer)
			return (Integer)getOperand1().Value(vm) *
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real)
			return ((Number)getOperand1().Value(vm)).floatValue() *
				((Number)getOperand2().Value(vm)).floatValue();
		return new ErrorValue();
	}
	eq Division.Value(State vm) {
		if (Type() == Type.Integer && (Integer)getOperand2().Value(vm) != 0)
			return (Integer)getOperand1().Value(vm) /
				(Integer)getOperand2().Value(vm);
		if (Type() == Type.Real && ((Number)getOperand2().Value(vm)).floatValue() != 0)
			return ((Number)getOperand1().Value(vm)).floatValue() /
				((Number)getOperand2().Value(vm)).floatValue();
		return new ErrorValue();
	}
	
	/** Program Interpretation */
	
	eq Statement.Interpret(State vm) = vm;
}
