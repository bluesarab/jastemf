/**
 * <copyright>
 *
 * This program and the accompanying materials are made available under the
 * terms of the BSD 3-clause license which accompanies this distribution.
 *
 * </copyright>
 */

/**
 * @author C. BÃ¼rger
 */
aspect NameAnalysis {
	/** Variable declaration name analysis */
	
	syn Collection<VariableDeclaration> CompilationUnit.LookUpVDecl(String name) =
		new LinkedList<VariableDeclaration>();
	eq CompilationUnit.getBlock().LookUpVDecl(String name) =
		new LinkedList<VariableDeclaration>();
	eq Block.getStatement(int index).LookUpVDecl(String name) {
		Collection<VariableDeclaration> result =
			new LinkedList<VariableDeclaration>();
		for (int i = 0; i < index; i++)
			result.addAll(getStatement(i).LookUpLocal(name));
		return !result.isEmpty() ? result : LookUpVDecl(name);
	}
	syn Collection<VariableDeclaration> Statement.LookUpLocal(String name) =
		new LinkedList<VariableDeclaration>();
	eq VariableDeclaration.LookUpLocal(String name) {
		if (!getName().equals(name))
			return new LinkedList<VariableDeclaration>();
		Collection<VariableDeclaration> result =
			new LinkedList<VariableDeclaration>();
		result.add(this);
		return result;
	}
	
	eq Reference.Declaration() = LookUpVDecl(getName()).size() == 1 ?
			LookUpVDecl(getName()).iterator().next() :
			null;

	eq VariableAssignment.Declaration() =
		LookUpVDecl(getLValue()).size() == 1 ?
			LookUpVDecl(getLValue()).iterator().next() :
			null;
	
	/** Assignment name analysis */
	
	VariableAssignment contributes this to
		CompilationUnit.Assignments() for ASTRoot();
	
	eq ASTNode.LookUpVAssignment(VariableDeclaration decl) {
		java.util.List<VariableAssignment> assigns =
			new LinkedList<VariableAssignment>();
		for (VariableAssignment assign:ASTRoot().Assignments())
			if (assign.Declaration() == decl)
				assigns.add(assign);
		Collections.sort(
				assigns,
				new Comparator<VariableAssignment>() {
					public int compare(VariableAssignment o1, VariableAssignment o2) {
						return o1.NodeAddress().compareTo(o2.NodeAddress());
					}
				});
		return !assigns.isEmpty() ? assigns.get(0) : null;
	}
}
