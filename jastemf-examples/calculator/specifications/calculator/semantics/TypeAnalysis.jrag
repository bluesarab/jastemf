/**
 * <copyright>
 *
 * This program and the accompanying materials are made available under the
 * terms of the BSD 3-clause license which accompanies this distribution.
 *
 * </copyright>
 */

/**
 * @author C. BÃ¼rger
 */
aspect TypeAnalysis {
	eq VariableDeclaration.Type() = getDeclaredType();
	eq VariableAssignment.Type() {
		VariableDeclaration decl = Declaration();
		if (decl == null)
			return Type.ERROR_TYPE;
		Type cT = Type.computeCompatibleType(decl.Type(), getRValue().Type());
		return cT != decl.Type() ? Type.ERROR_TYPE : decl.Type();
	}
	
	eq Constant.Type() {
		if (AsBoolean() != null)
			return Type.Boolean;
		if (AsReal() != null)
			return Type.Real;
		if (AsInteger() != null)
			return Type.Integer;
		return Type.ERROR_TYPE;
	}
	eq Reference.Type() = Declaration() != null ?
			Declaration().Type() : Type.ERROR_TYPE;
	eq ProcedureCall.Type() = Declaration() != null ?
			Declaration().getReturnType() :
			Type.ERROR_TYPE;
	eq NestedExpression.Type() = getExpression().Type();
	eq UMinus.Type() = getOperand().Type() == Type.Boolean ?
			Type.ERROR_TYPE :
			getOperand().Type();
	eq Not.Type() = getOperand().Type() == Type.Boolean ?
			Type.Boolean :
			Type.ERROR_TYPE;
	eq Or.Type() = getOperand1().Type() == Type.Boolean && getOperand2().Type() == Type.Boolean ?
			Type.Boolean :
			Type.ERROR_TYPE;
	eq And.Type() = getOperand1().Type() == Type.Boolean && getOperand2().Type() == Type.Boolean ?
			Type.Boolean :
			Type.ERROR_TYPE;
	eq Equal.Type() = Type.computeCompatibleType(getOperand1().Type(), getOperand2().Type()) == Type.ERROR_TYPE ?
			Type.ERROR_TYPE :
			Type.Boolean;
	eq BinaryExpression.Type() = Type.computeCompatibleType(
			getOperand1().Type(),
			getOperand2().Type());
}
