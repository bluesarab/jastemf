import java.util.*;
import java.io.*;

import ast.AST.*;
import jrag.*;

import jrag.AST.ASTCompilationUnit;
import jrag.AST.ASTBlock;

import jastadd.JastAdd;

aspect JragCodeGen {

  public static boolean ASTNode.beaver;
  public static boolean ASTNode.lazyMaps;
  public static boolean ASTNode.noInhEqCheck;

  public static boolean ASTNode.aspectJ = false;
  public static boolean ASTNode.rewriteEnabled = false;
  public static boolean ASTNode.circularEnabled = true;
  public static boolean ASTNode.visitCheckEnabled = true;
  public static boolean ASTNode.traceVisitCheck = false;
  public static boolean ASTNode.cacheCycle = true;
  public static boolean ASTNode.componentCheck = true;

  public static boolean ASTNode.suppressWarnings = false;

  public static boolean ASTNode.parentInterface = false;

  public static boolean ASTNode.doc = false;

  public static String ASTNode.license = "";

  public static boolean ASTNode.refineLegacy = false;
  public static boolean ASTNode.stagedRewrites = false;
  
  //--->added options and helpers for JastEMF
  public static final String ASTNode.listName = "ASTList";
  public static final String ASTNode.nodeName = "ASTNode";
  public static final String ASTNode.optName = "Opt";
  public static final String ASTNode.implSuffix = "Impl";
  
  public static boolean ASTNode.isBuiltInType(String typeName) {
	  return ASTNode.listName.equals(typeName)||
			  ASTNode.nodeName.equals(typeName)||
			  ASTNode.optName.equals(typeName);
  }
  
  public static boolean ASTNode.isBuiltInList(String typeName) {
	  return ASTNode.listName.equals(typeName);
  }
  
  public static boolean ASTNode.isBuiltInNode(String typeName) {
	  return ASTNode.nodeName.equals(typeName);
  }
  
  public static boolean ASTNode.isBuiltInOpt(String typeName) {
	  return ASTNode.optName.equals(typeName);
  }
  
  inh Grammar ASTNode.env();
  syn Grammar Grammar.env() = this;
  
  public String ASTNode.computeImplName(String typeName) {
	  return ASTNode.isBuiltInType(typeName)||env().lookup(typeName)==null?typeName:typeName+implSuffix;
  }
  //<---JastEMF additions end
  
  //public static int ASTNode.cycleLimit = 100;
  //public static int ASTNode.rewriteLimit = 100;
  //public static boolean ASTNode.debugMode = true;

  public static int ASTNode.cycleLimit = 0;
  public static int ASTNode.rewriteLimit = 0;
  public static boolean ASTNode.debugMode = false;

  public static boolean ASTNode.block = false;
  public static String ASTNode.blockBegin = "        synchronized(ASTNode.class) {\n";
  public static String ASTNode.blockEnd =   "        }\n";

  public static boolean ASTNode.noStatic = false;
  
  public static String ASTNode.createDefaultMap = "new java.util.HashMap(4)";
  public static String ASTNode.createDefaultSet = "new java.util.HashSet(4)";
  public static String ASTNode.typeDefaultMap = "java.util.Map";
  public static String ASTNode.typeDefaultSet = "java.util.Set";

  public static boolean ASTNode.deterministic;

  public static boolean ASTNode.tracing;
  public static boolean ASTNode.cacheAll = false;
  public static boolean ASTNode.noCaching = false;

  refine Ast public boolean AttrDecl.getLazy() {
    return (Ast.AttrDecl.getLazy() || cacheAll) && (!noCaching || declaredNTA());
  }

  refine Ast public boolean SynDecl.getLazy() {
    return (Ast.SynDecl.getLazy() || cacheAll) && (!noCaching || declaredNTA());
  }
  refine Ast public boolean InhDecl.getLazy() {
    return (Ast.InhDecl.getLazy() || cacheAll) && (!noCaching || declaredNTA());
  }
  refine Ast public boolean CollDecl.getLazy() {
    return (Ast.CollDecl.getLazy() || cacheAll) && !noCaching;
  }

  public void Grammar.genAGCode(PrintStream s, String aspectName) {
    aspectJ = true;
    
    s.print(genImportsList());
    s.print("aspect " + aspectName + " {\n");
    for(int i = 0; i < getNumTypeDecl(); i++) {
      getTypeDecl(i).genAGCode(s);
    }
    s.print("}\n");
  }

  public void TypeDecl.genAGCode(PrintStream s) {
  }
  
  public void ASTDecl.genAGCode(PrintStream s) {
    s.print(genImplementsList());
    s.print(genMembers());
    s.print(genAbstractSyns());
    s.print(genSynEquations());
    s.print(genInhDeclarations());
    s.print(genInhEquations());
  }

  public String Grammar.genImportsList() {
    LinkedHashSet set = new LinkedHashSet();
    for(Iterator iter = getCompUnits(); iter.hasNext(); ) {
        jrag.AST.ASTCompilationUnit u = (jrag.AST.ASTCompilationUnit)iter.next();
        String[] imports = u.getImports().split(";");
        for(int i = 0; i < imports.length; i++)
          if(imports[i] != null && !imports[i].equals(""))
            set.add(imports[i] + ";");
    }
    StringBuffer buf = new StringBuffer();
    for(Iterator iter = set.iterator(); iter.hasNext(); )
      buf.append(iter.next());
    buf.append("\n");
    return buf.toString();
  }
  public String ASTDecl.genImplementsList() {
    if(ASTNode.aspectJ && ASTNode.parentInterface) {
      StringBuffer buf = new StringBuffer();
      Iterator iter = inhAttrSet();
      if(iter.hasNext()) {
        buf.append("    declare parents: " + name() + " implements " +
            "Defines_" + (String)iter.next());
        while(iter.hasNext()) {
          buf.append(", Defines_" + (String)iter.next());
        }
        buf.append(";\n\n");
      }
      return buf.toString();
    }
    else
      return "";
  }

  public String InterfaceDecl.genMembers() {
    StringBuffer buf = new StringBuffer();
    for(Iterator iter = getClassBodyDecls(); iter.hasNext(); ) {
      ClassBodyObject o = (ClassBodyObject)iter.next();
      jrag.AST.SimpleNode n = o.node;
      buf.append("    // Declared in " + o.fileName + " at line " + o.line + "\n");
      if(n instanceof jrag.AST.ASTAspectMethodDeclaration) {
        try {
        jrag.AST.ASTAspectMethodDeclaration decl = (jrag.AST.ASTAspectMethodDeclaration)n;
        decl.unparseAbstractClassBodyDeclaration(buf, name(), aspectJ);
        } catch (Exception e) {
          System.out.println("Error generating " + o.signature() + " in " + name());
          e.printStackTrace();
        }
      }
      else if(n instanceof jrag.AST.ASTAspectRefineMethodDeclaration) {
        try {
              jrag.AST.ASTAspectRefineMethodDeclaration decl = (jrag.AST.ASTAspectRefineMethodDeclaration)n;
              decl.unparseAbstractClassBodyDeclaration(buf, name(), aspectJ);
              } catch (Exception e) {
                System.out.println("Error generating " + o.signature() + " in " + name());
                e.printStackTrace();
              }
      }
      else if(n instanceof jrag.AST.ASTBlock) {
    	  // do not emit refined implementations
      }
      else {
        if(!o.comments.equals(""))
          buf.append(o.comments + " ");
        n.unparseClassBodyDeclaration(buf, name(), aspectJ);
      }
      buf.append("\n\n");
    }
    return buf.toString();
  }

  public String TypeDecl.genMembers() { return ""; }

  public String ASTDecl.genMembers() {
    StringBuffer buf = new StringBuffer();
    for(Iterator iter = getClassBodyDecls(); iter.hasNext(); ) {
      ClassBodyObject o = (ClassBodyObject)iter.next();
      jrag.AST.SimpleNode n = o.node;
      buf.append("    // Declared in " + o.fileName + " at line " + o.line + "\n");
      if(!o.comments.equals(""))
        buf.append(o.comments + " ");
      n.unparseClassBodyDeclaration(buf, name(), aspectJ);
      buf.append("\n\n");
    }
    return buf.toString();
  }

  public static String ASTNode.suppressWarnings() {
    return " @SuppressWarnings({\"unchecked\", \"cast\"}) " ;
  }
  
  public String TypeDecl.genAbstractSyns() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      String s = attr.hostFileComment() + suppressWarnings() +
      "    public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#);\n";
      s = s.replaceAll("#TYPE#", attr.implType());
      s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
      if(!aspectJ){
        s = s.replaceAll("#CLASS#\\.", "");
      
      }
      else
        s = s.replaceAll("#CLASS#", implName());
      s = s.replaceAll("#METHODNAME#", attr.attributeName());
      s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
      buf.append(s);
    }
    return buf.toString();
  }
  

  public String ASTDecl.genAbstractSyns() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumSynDecl(); i++) {
      AttrDecl attr = getSynDecl(i);
      boolean equ = false;
      for(int j = 0; j < getNumSynEq(); j++) {
        if(getSynEq(j).getName().equals(attr.getName())) {
          equ = true;
        }
      }
      if(!equ) {
        String s;
        s = attr.hostFileComment() + suppressWarnings() + 
        "    public abstract #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#);\n";
        s = s.replaceAll("#TYPE#", attr.implType());
        s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
        if(!aspectJ)
          s = s.replaceAll("#CLASS#\\.", "");
        else
          s = s.replaceAll("#CLASS#", implName());
        s = s.replaceAll("#METHODNAME#", attr.attributeName());
        s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
        buf.append(s);
      }
    }
    return buf.toString();
  }
  
  public String AttrDecl.attributeSignature() {
    if(getNumParameter() == 0)
      return getName();
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }

  public String AttrDecl.attributeName() {
    return getName();
  }
  
  public String AttrEq.attributeSignature() {
    if(getNumParameter() == 0)
      return getName();
    StringBuffer s = new StringBuffer();
    s.append(getName());
    for(int i = 0; i < getNumParameter(); i++) {
      s.append("_" + getParameter(i).getTypeInSignature());
    }
    return s.toString();
  }

  public String AttrEq.attributeName() {
    return getName();
  }
  
  public String AttrDecl.hostFileComment() {
    String comment = getComment().trim();
    if(comment.equals("") || comment.indexOf("/**") == -1)
      return "    // Declared in " + getFileName() + " at line " + getStartLine() + "\n";
    else {
      int index = comment.indexOf("*/");
      StringBuffer res = new StringBuffer();
      res.append(comment.substring(0, index));
      res.append("\n");
      res.append("    Declared in " + getFileName() + " at line " + getStartLine() + "\n");
      res.append(comment.substring(index, comment.length()));
      res.append("\n");
      return res.toString();
    }
  }
  public String AttrEq.hostFileComment() {
    String comment = getComment().trim();
    if(comment.equals(""))
      comment = decl().getComment().trim();
    if(comment.equals("") || comment.indexOf("/**") == -1)
      return "    // Declared in " + getFileName() + " at line " + getStartLine() + "\n";
    else {
      int index = comment.indexOf("*/");
      StringBuffer res = new StringBuffer();
      res.append(comment.substring(0, index));
      res.append("\n");
      res.append("    Declared in " + getFileName() + " at line " + getStartLine() + "\n");
      res.append(comment.substring(index, comment.length()));
      res.append("\n");
      return res.toString();
    }
  }
  
  public String AttrDecl.initLazyMaps() {
    StringBuffer s = new StringBuffer();
    if(ASTNode.lazyMaps) {
      if(!isCircular()) {
        if(getNumParameter() != 0 && visitCheckEnabled() && rewriteEnabled) {
          s.append("if(#NAME#_visited == null) #NAME#_visited = " + createDefaultMap + ";\n");
        }
        else if(getNumParameter() != 0 && visitCheckEnabled()) {
          s.append("if(#NAME#_visited == null) #NAME#_visited = " + createDefaultSet + ";\n");
        }
      }
      if(getNumParameter() != 0 && (getLazy() || isCircular())) {
        s.append("if(#NAME#_values == null) #NAME#_values = " + createDefaultMap + ";\n");
      }
    }
    return s.toString();
  }

  syn boolean AttrDecl.visitCheckEnabled() = visitCheckEnabled;
  
  public String AttrDecl.visitedDeclarations() {
    if(isCircular()) {
      if(getNumParameter() == 0)
        return "    protected int #CLASS#.#NAME#_visited = -1;\n";
      else {
        // the visited flag is part of the State$Value object
        return "";
      }
    }
    if(!visitCheckEnabled() && !isCircular()) return "";
    if(rewriteEnabled) {
      if(getNumParameter() == 0)
        return "    protected int #CLASS#.#NAME#_visited = -1;\n";
      else {
        if(ASTNode.lazyMaps)
          return "    protected " + typeDefaultMap + " #CLASS#.#NAME#_visited;\n";
        else
          return "    protected " + typeDefaultMap + " #CLASS#.#NAME#_visited = " + createDefaultMap + ";\n";
      }
    }
    if(getNumParameter() == 0)
      return "    protected boolean #CLASS#.#NAME#_visited = false;\n";
    else {
      if(ASTNode.lazyMaps)
        return "    protected " + typeDefaultSet + " #CLASS#.#NAME#_visited;\n";
      else
        return "    protected " + typeDefaultSet + " #CLASS#.#NAME#_visited = " + createDefaultSet + ";\n";
    }
  }
  
  public String AttrDecl.visitedException() {
    if(!visitCheckEnabled()) return "";
    if(!traceVisitCheck)
      return "            throw new RuntimeException(\"Circular definition of attr: #METHODNAME# in class: #CLASS#.\");\n";
    else
      return "            System.out.println(\"Circular definition of attr: #METHODNAME# in class: \" + getClass().getName());\n";
  }
      
  public String AttrDecl.resetVisit() {
    if(isCircular()) {
      if(getNumParameter() == 0)
        return "        #NAME#_visited = -1;\n";
      else {
        // visited is handled in value object
        return "";
      }
    }
    if(!visitCheckEnabled()) return "";
    else if(rewriteEnabled) {
      if(getNumParameter() == 0)
        return "        #NAME#_visited = -1;\n";
      else {
        if(ASTNode.lazyMaps)
          return "        #NAME#_visited = null;\n";
        else
          return "        #NAME#_visited = " + createDefaultMap + ";\n";
      }
    }
    if(getNumParameter() == 0)
      return "        #NAME#_visited = false;\n";
    else {
      if(ASTNode.lazyMaps)
        return "        #NAME#_visited = null;\n";
      else
        return "        #NAME#_visited = " + createDefaultSet + ";\n";
    }
  }
      
  public String AttrDecl.visitedCheck() {
    if(!visitCheckEnabled()) return "";
    if(rewriteEnabled) {
      if(getNumParameter() == 0)
        return "        if(#NAME#_visited == state().boundariesCrossed)\n" + 
                          visitedException();
      else {
          return "        if(Integer.valueOf(state().boundariesCrossed).equals(#NAME#_visited.get(_parameters)))\n" + 
                          visitedException();
      }
    }
    if(getNumParameter() == 0)
      return "        if(#NAME#_visited)\n" + 
                          visitedException();
    else
      return "        if(#NAME#_visited.contains(_parameters))\n" + 
                          visitedException();
  }
  
  public String AttrDecl.setVisited() {
    if(!visitCheckEnabled() && !isCircular()) return "";
    if(rewriteEnabled) {
      if(getNumParameter() == 0)
        return "        #NAME#_visited = state().boundariesCrossed;\n";
      else {
        return "        #NAME#_visited.put(_parameters, Integer.valueOf(state().boundariesCrossed));\n";
      }
    }
    if(getNumParameter() == 0)
      return "        #NAME#_visited = true;\n";
    else
      return "        #NAME#_visited.add(_parameters);\n";
  }
  
  public String AttrDecl.clearVisited() {
    if(!visitCheckEnabled() && !isCircular()) return "";
    if(rewriteEnabled) {
      if(getNumParameter() == 0)
        return "        #NAME#_visited = -1;\n";
      else
        return "        #NAME#_visited.remove(_parameters);\n";
    }
    if(getNumParameter() == 0)
      return "        #NAME#_visited = false;\n";
    else
      return "        #NAME#_visited.remove(_parameters);\n";
  }  
  
  public String AttrDecl.cacheDeclarations() {
    if(!getLazy())
      return "";
    if(getNumParameter() == 0)
      return "    protected boolean #CLASS#.#NAME#_computed = false;\n" + 
             "    protected #TYPE# #CLASS#.#NAME#_value;\n";
    else if(declaredNTA()) {
      if(ASTNode.lazyMaps)
        return "    protected " + typeDefaultMap + " #CLASS#.#NAME#_values;\n" +
               "    protected " + ASTNode.listName + " #CLASS#.#NAME#_list;\n";
      else
        return "    protected " + typeDefaultMap + " #CLASS#.#NAME#_values = " + createDefaultMap + ";\n" +
               "    protected " + ASTNode.listName + " #CLASS#.#NAME#_list;\n";
    }
    else {
      if(ASTNode.lazyMaps)
        return "    protected " + typeDefaultMap + " #CLASS#.#NAME#_values;\n";
      else
        return "    protected " + typeDefaultMap + " #CLASS#.#NAME#_values = " + createDefaultMap + ";\n";
    }
  }
  syn boolean AttrDecl.declaredNTA() = false;
  eq SynDecl.declaredNTA() = getNTA();
  eq InhDecl.declaredNTA() = getNTA();

  public String AttrDecl.resetCache() {
    if(!getLazy() && !isCircular())
      return "";
    if(getNumParameter() == 0) {
      if(isCircular()) {
        if(isPrimitive())
          return "        #NAME#_computed = false;\n" +
                 "        #NAME#_initialized = false;\n";
        else
          return "        #NAME#_computed = false;\n" +
                 "        #NAME#_initialized = false;\n" +
                 "        #NAME#_value = null;\n";
      }
      if(isPrimitive())
        return "        #NAME#_computed = false;\n";
      else
        return "        #NAME#_computed = false;\n" +
               "        #NAME#_value = null;\n";
    }
    else if(isCircular()) {
        if(ASTNode.lazyMaps)
          return "        #NAME#_values = null;\n";
        else
          return "        #NAME#_values = " + createDefaultMap + ";\n";
    }
    else {
      if(ASTNode.lazyMaps)
        return "        #NAME#_values = null;\n";
      else
        return "        #NAME#_values = " + createDefaultMap + ";\n";
    }
  }
  
  public String Parameter.toReferenceType() {
    return toReferenceType(getName(), getType());
  }
  
  public String ASTNode.toReferenceType(String value, String type) {
    if(type.equals("int"))
      return "Integer.valueOf(" + value + ")" ;
    else if(type.equals("short"))
      return "Short.valueOf(" + value + ")" ;
    else if(type.equals("long"))
      return "Long.valueOf(" + value + ")" ;
    else if(type.equals("float"))
      return "Float.valueOf(" + value + ")" ;
    else if(type.equals("double"))
      return "Double.valueOf(" + value + ")" ;
    else if(type.equals("boolean"))
      return  ("Boolean.valueOf(" + value + ")");
    else if(type.equals("char"))
      return "Character.valueOf(" + value + ")" ;
    else return value;
  }
  
  public String ASTNode.fromReferenceType(String value, String type) {
    if(type.equals("int"))
      return "((Integer)" + value + ").intValue()";
    else if(type.equals("short"))
      return "((Short)" + value + ").shortValue()";
    else if(type.equals("long"))
      return "((Long)" + value + ").longValue()";
    else if(type.equals("float"))
      return "((Float)" + value + ").floatValue()";
    else if(type.equals("double"))
      return "((Double)" + value + ").doubleValue()";
    else if(type.equals("boolean"))
      return "((Boolean)" + value + ").booleanValue()";
    else if(type.equals("char"))
      return "((Character)" + value + ").charValue()";
    else
      return "(" + type + ")" + value;
  }

  public boolean AttrDecl.isPrimitive() {
	String type = getType();
	return type.equals("int") || type.equals("short") || type.equals("long") || 
	       type.equals("float") || type.equals("double") || type.equals("boolean") ||
	       type.equals("char") || type.equals("byte");
  }
  public boolean AttrDecl.isPrimitive(String type) {
	  return type.equals("int") || type.equals("short") || type.equals("long") || 
	       type.equals("float") || type.equals("double") || type.equals("boolean") ||
	       type.equals("char") || type.equals("byte");
  }
  
  public String AttrDecl.cacheCheck() {
    if(!getLazy() && !isCircular())
      return "";
    if(isNTA() && !(findCorrespondingNTA() instanceof TokenComponent)) {
      int index = indexNTAchild();
      if(getNumParameter() == 0)
        return "        if(#NAME#_computed) {\n" +
               traceEndCachedAttr() +
               "            return (" + getType() + ")ASTNode.getChild(this, #NAME#ChildPosition());\n" +
               "        }\n";
      else
        return "        if(#NAME#_values.containsKey(_parameters)) {\n" + 
               traceEndCachedAttr() +
               "            return (" + getType() + ")ASTNode.getChild(this, #NAME#ChildPosition()));\n" +
               "        }\n";
    }
    if(getNumParameter() == 0)
      return "        if(#NAME#_computed) {\n" + 
             traceEndCachedAttr() +
             "            return #NAME#_value;\n" +
             "        }\n";
    else {
      if(isCircular())
        return "        if(#NAME#_values.containsKey(_parameters)) {\n" + 
               "            Object _o = #NAME#_values.get(_parameters);\n" +
               "            if(!(_o instanceof ASTNode$State.CircularValue)) {\n" +
               traceEndCachedAttr() +
               "                return " + fromReferenceType("_o", getType()) + ";\n" +
               "            }\n" +
               "            else\n" +
               "                _value = (ASTNode$State.CircularValue)_o;\n" +
               "        }\n";
      else
        return "        if(#NAME#_values.containsKey(_parameters)) {\n" + 
               traceEndCachedAttr() +
               "            return " + fromReferenceType("#NAME#_values.get(_parameters)", getType()) + ";\n" +
               "        }\n";
    }
  }
  
  public String AttrDecl.parameterStructure() {
    if(getNumParameter() == 0 || (!getLazy() && !isCircular() && !visitCheckEnabled()))
      return "";
    else if(getNumParameter() == 1)
      return "        Object _parameters = " + getParameter(0).toReferenceType() + ";\n";
    else {
      StringBuffer s = new StringBuffer();
        s.append("        java.util.List _parameters = new java.util.ArrayList(" + getNumParameter() + ");\n");
      for(int i = 0; i < getNumParameter(); i++) {
        s.append("        _parameters.add(" + getParameter(i).toReferenceType() + ");\n");
      }
      return s.toString();
    }
  }
  
  public String AttrDecl.cacheInit() {
    if(!getLazy())
      return "";
    return cacheInitRewrite();
  }
  
  public String AttrDecl.cacheInitRewrite() {
    if(!ASTNode.rewriteEnabled) {
      return "";
    }
    else {
      return "        int num = state.boundariesCrossed;\n" + 
             "        boolean isFinal = this.is$Final();\n";
    }
  }
  
  public String AttrDecl.callCompute() {
    if(getLazy() && getNumParameter() == 0)
      return "        #NAME#_value = #METHODNAME#_compute(#PARM#);\n";
    else 
      return "        #TYPE# #NAME#_value = #METHODNAME#_compute(#PARM#);\n";
  }

  // TODO: INH
  public String InhDecl.callCompute() {
    if(ASTNode.parentInterface)
      return super.callCompute();
    else {
      if(getLazy() && getNumParameter() == 0)
        return inhDebugString() + 
               "        #NAME#_value = getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + interfaceParametersStart() + ");\n";
      else 
        return inhDebugString() + 
               "        #TYPE# #NAME#_value = getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + interfaceParametersStart() + ");\n";
    }
  }
  
  public String AttrDecl.cacheStoreRewrite() {
    if(!ASTNode.rewriteEnabled || getFinal())
      return   "        if(true)\n";
    else
      return   "        if(isFinal && num == state().boundariesCrossed)\n";
  }

  public String AttrDecl.cacheStore() {
    if(!getLazy())
      return "";
	if(getNumParameter() == 0)
	  return cacheStoreRewrite() +
	         "            #NAME#_computed = true;\n";
	else
	  return cacheStoreRewrite() + 
             "            #NAME#_values.put(_parameters, " + toReferenceType("#NAME#_value", getType()) + ");\n";
  }
  
  public String AttrDecl.returnStmt() {
    if(isNTA() && !(findCorrespondingNTA() instanceof TokenComponent)) {
      int index = indexNTAchild();
      return "        return (" + getType() + ")ASTNode.getChild(this, #NAME#ChildPosition());\n";
    }
    return "        return #NAME#_value;\n";
  }
  
  public String AttrEq.computeMethod() {
    return "";
  }
  
  public String SynEq.computeMethod() {
    if(getRHS() instanceof ASTBlock) // Block
      return "    private #TYPE# #CLASS#.#METHODNAME#_compute(#PARMDECL#) " + getRHS().unparse() + "\n\n";
    else // Expr
      return "    private #TYPE# #CLASS#.#METHODNAME#_compute(#PARMDECL#) {  return " + getRHS().unparse() + ";  }\n\n";
  }
  
  public String AttrDecl.computeMethod() {
    // TODO: INH
    if(!ASTNode.parentInterface)
      return  "";
    return  "    private #TYPE# #CLASS#.#METHODNAME#_compute(#PARMDECL#) {\n" +
            "            ASTNode n = getParent();\n" + 
            "            ASTNode caller = this;\n" + 
            "            ASTNode child = null;\n" + 
            "            while(!(n instanceof Defines_#TYPEINSIGNATURE#_#NAME#) && n != null) {\n" +
            "                child = caller;\n" + 
            "                caller = n;\n" + 
            "                n = n.getParent();\n" + 
            "            }\n" +
            inhDebugString() +
            "            return ((Defines_#TYPEINSIGNATURE#_#NAME#)n).Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARM#);\n" + 
            "    }\n\n";
  }

  syn String AttrDecl.inhDebugString() {
    if(!debugMode) return "";
    if(ASTNode.parentInterface)
      return "        if(n == null) throw new RuntimeException(\"Trying to evaluate attribute in subtree not attached to main tree\");\n";
    else
      return "        if(getParent() == null) throw new RuntimeException(\"Trying to evaluate attribute in subtree not attached to main tree\");\n";
  }

  public boolean TypeDecl.hasLazySynEqFor(AttrDecl attr) {
    if(attr instanceof SynDecl) {
      SynEq synEq = lookupSynEq(attr.signature());
      return synEq != null && (synEq.decl().getLazy() || synEq.decl().isCircular()) ;
    }
    return false;
  }

  syn String AttrDecl.cycleLimitCheck() = "";
   // TODO: fixme cycleLimit > 0 ?
   //    "if(state().CIRCLE_INDEX > " + cycleLimit + ") throw new java.lang.RuntimeException(\"Iteration limit " + cycleLimit + " exceeded\");\n" : "";
  
  public String ASTDecl.genEquation(AttrDecl attr, String comment) {
    boolean needsCacheDeclaration = true;
    if(attr instanceof SynDecl)
      needsCacheDeclaration = superClass() == null || !superClass().hasLazySynEqFor(attr);
    if (!attr.isCircular()) {
      return
           (needsCacheDeclaration ? (attr.visitedDeclarations() + attr.cacheDeclarations()) : "") + 
           comment +
           suppressWarnings() +
           "    public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#) {\n" + 
           (ASTNode.block ? ASTNode.blockBegin : "") +
           attr.parameterStructure() +
           attr.traceBeginAttr() +
           attr.initLazyMaps() +
           attr.cacheCheck() + 
           (ASTNode.rewriteEnabled ? "        ASTNode$State state = state();\n" : "") +
           attr.addInterruptedCircleDeclaration() +
           attr.visitedCheck() + 
           attr.setVisited() +
           attr.addCheckInterruptedCircle() +
           attr.cacheInit() + 
           attr.callCompute() + 
           attr.higherOrderAttributeCode() + 
           attr.cacheStore() + 
           attr.clearVisited() +
           attr.addClearInterruptedCircle() +
           attr.traceEndAttr() +
           attr.returnStmt() + 
           (ASTNode.block ? ASTNode.blockEnd : "") +
           "    }\n\n";
    }
    else {   
      if(attr.getNumParameter() == 0) {
        if(!needsCacheDeclaration && attr instanceof SynDecl &&
          superClass() != null && superClass().lookupSynEq(attr.signature()) != null
          && !superClass().lookupSynEq(attr.signature()).decl().isCircular())
          needsCacheDeclaration = true;
        return 
           (needsCacheDeclaration ?
           (
             attr.visitedDeclarations() + 
             "    protected boolean #CLASS#.#NAME#_computed = false;\n" + 
             "    protected boolean #CLASS#.#NAME#_initialized = false;\n" +
             "    protected #TYPE# #CLASS#.#NAME#_value;\n"
           ) : "" ) +
           comment +
           suppressWarnings() +
           "    public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#) {\n" + 
           (ASTNode.block ? ASTNode.blockBegin : "") +
           attr.traceComputeContext() +
           attr.parameterStructure() + 
           attr.cacheCheck() +
           "        ASTNode$State state = state();\n" +
           attr.addComponentCheck() +
           "        if (!#NAME#_initialized) {\n" +
           "            #NAME#_initialized = true;\n" + 
           "            #NAME#_value = " + attr.getBottomValue().unparse() + ";\n" +
           "        }\n" +
           "        if (!state.IN_CIRCLE) {\n" +
           "            state.IN_CIRCLE = true;\n" +
           attr.tracePrintCycleBeginString() +
           attr.addAddToComponent() +
           "    " + attr.cacheInitRewrite() + 
        //   "            state().CIRCLE_INDEX = 1;\n" + // TODO: fixme
           "            do {\n" +
           "                #NAME#_visited = state.CIRCLE_INDEX;\n" +
           "                state.CHANGE = false;\n" +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           "                #TYPE# new_#NAME#_value = " + attr.circularComputeCall() + ";\n" +
           "                if (" + attr.differs("new_#NAME#_value", "#NAME#_value") + ")\n" +
           "                    state.CHANGE = true;\n" +
           "                #NAME#_value = new_#NAME#_value; \n" +
           "                state.CIRCLE_INDEX++;\n" +
           attr.tracePrintStartingCycle() +
           attr.cycleLimitCheck() +
           "            } while (state.CHANGE);\n" +
           "    " + attr.cacheStoreRewrite() + "{\n" +
           "            #NAME#_computed = true;\n" +
           attr.cacheCycleInit() +
           "            }\n" +
           "            else {\n" +
           attr.resetCycleInit() +
	         "              #NAME#_computed = false;\n" +
           "              #NAME#_initialized = false;\n" + 
           "            }\n" +                
           "            state.IN_CIRCLE = false; \n" +
           attr.tracePrintReturnNewValue("#NAME#_value") +
           attr.tracePrintCycleEndString() +
           "    " + attr.returnStmt() +
           "        }\n" +
           "        if(#NAME#_visited != state.CIRCLE_INDEX) {\n" +
           "            #NAME#_visited = state.CIRCLE_INDEX;\n" +
           attr.cacheCycleCheck() +
           attr.resetCycleCheck() +
           attr.addAddToComponent() +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           "            #TYPE# new_#NAME#_value = " + attr.circularComputeCall() + ";\n" +
           "            if (" + attr.differs("new_#NAME#_value", "#NAME#_value") + ")\n" +
           "                state.CHANGE = true;\n" +
           "            #NAME#_value = new_#NAME#_value; \n" +
           attr.tracePrintReturnNewValue("#NAME#_value") +
           "    " + attr.returnStmt() +
           "        }\n" +
           attr.tracePrintReturnPreviousValue("#NAME#_value") +
           attr.returnStmt() + 
           (ASTNode.block ? ASTNode.blockEnd : "") +
           "    }\n\n";
      }
      else
        return
           (needsCacheDeclaration ?
           ( attr.visitedDeclarations() + 
             "    protected " + typeDefaultMap + " #CLASS#.#NAME#_values" + (ASTNode.lazyMaps ? "" : (" = " + createDefaultMap)) + ";\n"
           ) : "" ) +
           comment +
           suppressWarnings() + 
           "    public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#) {\n" + 
           (ASTNode.block ? ASTNode.blockBegin : "") +
           attr.traceComputeContext() +
           attr.parameterStructure() + 
           attr.initLazyMaps() +
           "        ASTNode$State.CircularValue _value;\n" +
           attr.cacheCheck() + 
           "        else {\n" +
           "            _value = new ASTNode$State.CircularValue();\n" +
           "            #NAME#_values.put(_parameters, _value);\n" +
           "            _value.value = " + toReferenceType(attr.getBottomValue().unparse(), attr.getType()) + ";\n" + 
           "        }\n" +
           "        ASTNode$State state = state();\n" +
           attr.addComponentCheck() +
           "        if (!state.IN_CIRCLE) {\n" +
           "            state.IN_CIRCLE = true;\n" +
           attr.tracePrintCycleBeginString() +
           "    " + attr.cacheInitRewrite() +
           attr.addAddToComponent() +
  // TODO: fixme         "            state().CIRCLE_INDEX = 1;\n" +
           "            #TYPE# new_#NAME#_value;\n" + 
           "            do {\n" +
           "                _value.visited = new Integer(state.CIRCLE_INDEX);\n" +
           "                state.CHANGE = false;\n" +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           "                new_#NAME#_value = " + attr.circularComputeCall() + ";\n" +
           "                if (" + attr.differs("new_#NAME#_value", fromReferenceType("_value.value", attr.getType())) + ") {\n" +
           "                    state.CHANGE = true;\n" +
           "                    _value.value = " + toReferenceType("new_#NAME#_value", attr.getType()) + ";\n" +
           "                }\n" +
           "                state.CIRCLE_INDEX++;\n" +
           attr.tracePrintStartingCycle() +
           attr.cycleLimitCheck() +
           "            } while (state.CHANGE);\n" +
           "    " + attr.cacheStoreRewrite() + "{\n" +
           "                #NAME#_values.put(_parameters, new_#NAME#_value);\n" +
           attr.cacheCycleInit() +
           "            }\n" +
           "            else {\n" +
           "                #NAME#_values.remove(_parameters);\n" + 
           attr.resetCycleInit() +
           "            }\n" +                
           "            state.IN_CIRCLE = false; \n" +
           attr.tracePrintReturnNewValue("new_#NAME#_value") +
           attr.tracePrintCycleEndString() +
           "            return new_#NAME#_value;\n" + 
           "        }\n" +
           "        if(!new Integer(state.CIRCLE_INDEX).equals(_value.visited)) {\n" +
           "            _value.visited = new Integer(state.CIRCLE_INDEX);\n" +
           attr.inhDebugString() +
           attr.tracePrintBeginComputingValue() +
           "            #TYPE# new_#NAME#_value = " + attr.circularComputeCall() + ";\n" +
           attr.cacheCycleCheck() +
           attr.resetCycleCheck() +
           "            else if (" + attr.differs("new_#NAME#_value", fromReferenceType("_value.value", attr.getType())) + ") {\n" +
           "                state.CHANGE = true;\n" +
           "                _value.value = new_#NAME#_value;\n" +
           "            }\n" +
           attr.tracePrintReturnNewValue("new_#NAME#_value") +
           "            return new_#NAME#_value;\n" + 
           "        }\n" +
           attr.tracePrintReturnPreviousValue(fromReferenceType("#NAME#_values.get(_parameters)" , attr.getType())) +
           "        return " + fromReferenceType("_value.value" , attr.getType()) + ";\n" + 
           (ASTNode.block ? ASTNode.blockEnd : "") +
           "    }\n\n";
    }
  }

  public String AttrDecl.circularComputeCall() { return ""; }
  public String SynDecl.circularComputeCall() { return "#METHODNAME#_compute(#PARM#)"; }
  public String InhDecl.circularComputeCall() {
    if(!ASTNode.parentInterface)
      return "getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + interfaceParametersStart() + ")";
    else
      return "#METHODNAME#_compute(#PARM#)";
  }
  
  public String AttrDecl.resetCycleInit() {
     return
        "            state.RESET_CYCLE = true;\n" +
        inhDebugString() +
        "            " + circularComputeCall() + ";\n" +
        "            state.RESET_CYCLE = false;\n";
  }

  public String AttrDecl.resetCycleCheck() {
     if(getNumParameter() == 0)
       return
         "            if (state.RESET_CYCLE) {\n" +
         "                #NAME#_computed = false;\n" +
         "                #NAME#_initialized = false;\n" + 
         "                #NAME#_visited = -1;\n" +
         "        " + returnStmt() + 
         "            }\n";
     else
       return
         "            if (state.RESET_CYCLE) {\n" +
         "                #NAME#_values.remove(_parameters);\n" + 
         "            }\n";
  }

  public String AttrDecl.cacheCycleInit() {
     if (! cacheCycle) return "";
     return
        "            state.LAST_CYCLE = true;\n" +
        inhDebugString() +
        "            " + circularComputeCall() + ";\n" +
        "            state.LAST_CYCLE = false;\n";
  }

  public String AttrDecl.cacheCycleCheck() {
     if (! cacheCycle) return "";
     if(getNumParameter() == 0)
       return
         "            if (state.LAST_CYCLE) {\n" +
         "                #NAME#_computed = true;\n" +
         inhDebugString() +
         "                return " + circularComputeCall() + ";\n" +
         "            }\n";
     else
       return
         "            if (state.LAST_CYCLE) {\n" +
         inhDebugString() +
         "                #NAME#_values.put(_parameters, new_#NAME#_value);\n" +
         "            }\n";
  }

  public String AttrDecl.addComponentCheck() {
    if(!componentCheck || !visitCheckEnabled) return "";
    String arg = getNumParameter() == 0 ? "null" : "_parameters";
    if(getNumParameter() == 0) {
      if(rewriteEnabled)
        return 
        "     if(#NAME#_visited == state.boundariesCrossed && !state.containsEvalEntry(this, \"#NAME#\", null))\n" +
        "       throw new java.lang.RuntimeException(\"XXX\");\n";
      else
        return 
        "     if(#NAME#_visited && !state.containsEvalEntry(this, \"#NAME#\", null))\n" +
        "       throw new java.lang.RuntimeException(\"XXX\");\n";
    }
    else {
      if(rewriteEnabled)
        return
        "     if(new Integer(state.boundariesCrossed).equals(_value.visited) && !state.containsEvalEntry(this, \"#NAME#\", _parameters))\n" +
        "       throw new java.lang.RuntimeException(\"XXX\");\n";
      else
        return
        "     if(_value.visited && !state.containsEvalEntry(this, \"#NAME#\", _parameters))\n" +
        "       throw new java.lang.RuntimeException(\"XXX\");\n";
    }
  }

  public String AttrDecl.addAddToComponent() {
    if(!componentCheck || !visitCheckEnabled) return "";
    if(getNumParameter() == 0)
      return
        "     state.addEvalEntry(this, \"#NAME#\", null);\n";
    else
      return
        "     state.addEvalEntry(this, \"#NAME#\", _parameters);\n";
  }

  public String AttrDecl.addInterruptedCircleDeclaration() {
    if(!componentCheck) return "";
    return "boolean interruptedCircle = false;\n";
  }

  public String AttrDecl.addCheckInterruptedCircle() {
    if(!componentCheck) return "";
    return 
      "if(state.IN_CIRCLE) {\n" + 
      "  interruptedCircle = true;\n" +
      "  state.IN_CIRCLE = false;\n" +
      "  state.pushEvalStack();\n" +
      "}\n";
  }

  public String AttrDecl.addClearInterruptedCircle() {
    if(!componentCheck) return "";
    return 
      "if(interruptedCircle) {\n" + 
      "  state.IN_CIRCLE = true;\n" +
      "  state.popEvalStack();\n" +
      "}\n";
  }
  
  public String AttrDecl.differs(String s1, String s2) {
    if (isPrimitive())
      return s1 + "!=" + s2;
    else
      return "(" + s1 + "==null && " + s2 + "!=null)" + " || " + "(" + s1 + "!=null && " + "!" + s1 + ".equals(" + s2 + ")" + ")";
  }
  
  public String ASTDecl.genSynEquations() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumSynEq(); i++) {
       AttrEq equ = getSynEq(i);;
       AttrDecl attr = equ.decl();
       String s = genEquation(attr, equ.hostFileComment()) + equ.computeMethod();
       s = s.replaceAll("#TYPE#", attr.implType());
       s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
       if(!aspectJ)
         s = s.replaceAll("#CLASS#\\.", "");
       else
         s = s.replaceAll("#CLASS#", implName());
       s = s.replaceAll("#NAME#", attr.attributeSignature());
       s = s.replaceAll("#METHODNAME#", attr.attributeName());
       s = s.replaceAll("#PARMDECL#", equ.parametersDecl());
       s = s.replaceAll("#PARM#", attr.parameters());
       s = s.replaceAll("#LISTTYPE#", ASTNode.listName);
       buf.append(s);
    }
    return buf.toString();
  }

  
  public boolean AttrDecl.isNTA() {
    return false;
  }

  public boolean SynDecl.isNTA() {
    return findCorrespondingNTA() != null;
  }

  public int AttrDecl.indexNTAchild() {
    Components comp = findCorrespondingNTA();
    TypeDecl c = hostClass();
    while(c != null) {
      int index = 0;
      for(Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components next = (Components)iter.next();
        if(next == comp)
          return index;
        if(!(next instanceof TokenComponent))
          index++;
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return -1;
  }

  public Components AttrDecl.findCorrespondingNTA() {
    if(!getName().startsWith("get"))
      return null;
    String attrName = getName().substring(3);
    TypeDecl c = hostClass();
    while(c != null) {
      for(Iterator iter = c.getComponents(); iter.hasNext(); ) {
        Components comp = (Components)iter.next();
        if(comp.name().equals(attrName) && (
            comp instanceof OptionalComponentNTA
            || comp instanceof TokenComponentNTA
            || comp instanceof AggregateComponentsNTA )) {
          return comp;
        }
        if(attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
          return comp;
        }
        if(attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
          return comp;
        }
      }
      c = c instanceof ASTDecl ? ((ASTDecl)c).superClass() : null;
    }
    return null;
  }
  
  public String AttrDecl.higherOrderAttributeCode() {
    return "";
  }
  
  public String SynDecl.higherOrderAttributeCode() {
    StringBuffer result = new StringBuffer();
    if(getNTA()) {
      if(ASTNode.rewriteEnabled) {
        if(ASTNode.stagedRewrites) {
          if(getNumParameter() == 0)
            return "        #NAME#_value.setParent(this);\n" +
              "        #NAME#_value.is$Final = java.lang.Integer.MAX_VALUE;\n";
          else 
            return "        if(#NAME#_list == null) {\n" +
              "            #NAME#_list = new #LISTTYPE#();\n" +
              "            #NAME#_list.is$Final = java.lang.Integer.MAX_VALUE;\n" +
              "            #NAME#_list.setParent(this);\n" + 
              "        }\n" +
              "        #NAME#_list.add(#NAME#_value);\n" + 
              "        #NAME#_value.is$Final = java.lang.Integer.MAX_VALUE;\n";
        }
        else {
          if(getNumParameter() == 0)
            return "        #NAME#_value.setParent(this);\n" +
              "        #NAME#_value.is$Final = true;\n";
          else 
            return "        if(#NAME#_list == null) {\n" +
              "            #NAME#_list = new #LISTTYPE#();\n" +
              "            #NAME#_list.is$Final = true;\n" +
              "            #NAME#_list.setParent(this);\n" + 
              "        }\n" +
              "        #NAME#_list.add(#NAME#_value);\n" + 
              "        #NAME#_value.is$Final = true;\n";
        }
      } 
      else {
        if(getNumParameter() == 0)
          return "        #NAME#_value.setParent(this);\n";
        else 
          return "        if(#NAME#_list == null) {\n" +
            "            #NAME#_list = new #LISTTYPE#();\n" +
            "            #NAME#_list.setParent(this);\n" + 
            "        }\n" +
            "        #NAME#_list.add(#NAME#_value);\n";
      }
    }
    Components comp = findCorrespondingNTA();
    if(comp != null) {
      String attrName = getName().substring(3); // remove get
      if(comp.name().equals(attrName) && (
            comp instanceof OptionalComponentNTA
            || comp instanceof TokenComponentNTA
            || comp instanceof AggregateComponentsNTA )) {
        result.append("            set" + attrName + "(#NAME#_value);\n");
      }
      if(attrName.equals(comp.name() + "Opt") && comp instanceof OptionalComponentNTA) {
        result.append("        set" + attrName + "(#NAME#_value);\n");
      }
      if(attrName.equals(comp.name() + "List") && comp instanceof ListComponentsNTA) {
        result.append("        set" + attrName + "(#NAME#_value);\n");
      }
    }
    return result.toString();
  }    

  public String TypeDecl.genInhDeclarations() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       buf.append(attr.hostFileComment());
       
       String s = "    public #TYPE# #CLASS#.#METHODNAME#(#PARMDECL#);\n";
       s = s.replaceAll("#TYPE#", attr.implType());
       s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
       if(!aspectJ)
         s = s.replaceAll("#CLASS#\\.", "");
       else
         s = s.replaceAll("#CLASS#", implName());
       s = s.replaceAll("#NAME#", attr.attributeSignature());
       s = s.replaceAll("#METHODNAME#", attr.attributeName());
       s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
       s = s.replaceAll("#PARM#", attr.parameters());
       s = s.replaceAll("#INTERFACEPARM#", attr.interfaceParameters());
       buf.append(s);
    }
    return buf.toString();
  }
  
  public String ASTDecl.genInhDeclarations() {
    StringBuffer buf = new StringBuffer();
    for(int i = 0; i < getNumInhDecl(); i++) {
       AttrDecl attr = getInhDecl(i);
       String s = genEquation(attr, attr.hostFileComment()) + attr.computeMethod();
       s = s.replaceAll("#TYPE#", attr.implType());
       s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
       if(!aspectJ)
         s = s.replaceAll("#CLASS#\\.", "");
       else
         s = s.replaceAll("#CLASS#", implName());
       s = s.replaceAll("#NAME#", attr.attributeSignature());
       s = s.replaceAll("#METHODNAME#", attr.attributeName());
       s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
       s = s.replaceAll("#PARM#", attr.parameters());
       s = s.replaceAll("#INTERFACEPARM#", attr.interfaceParameters());
       buf.append(s);
    }
    return buf.toString();
  }

  syn boolean TypeDecl.hasInhEq(String attrName) {
    for(int i = 0; i < getNumInhEq(); i++) {
      InhEq equ = getInhEq(i);
      if(equ.getName().equals(attrName)) {
        return true;
      }
    }
    return false;
  }
  eq ASTDecl.hasInhEq(String attrName) =
    super.hasInhEq(attrName) || superClass() != null && superClass().hasInhEq(attrName);

  syn Components InhEq.getComponents() {
    TypeDecl c = hostClass();
    if(c != null)
      return c.components(sonName());
    return  null;
  }
  syn String InhEq.sonName() = getSonName().startsWith("get") ? getSonName().substring(3) : getSonName();

  syn AttrDecl InhEq.getSonAttrDecl() {
    AttrDecl decl = hostClass().lookupSynDeclPrefix(sonName());
    if(decl == null) decl = hostClass().lookupInhDeclPrefix(sonName());
    return decl;
  }
  
  syn SynDecl TypeDecl.lookupSynDeclPrefix(String signature) {
    for(int i = 0; i < getNumSynDecl(); i++)
      if(getSynDecl(i).signature().equals(signature) || getSynDecl(i).signature().startsWith(signature + "_"))
        return getSynDecl(i);
    return null;
  }
  eq ASTDecl.lookupSynDeclPrefix(String signature) {
    SynDecl decl = super.lookupSynDeclPrefix(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupSynDeclPrefix(signature);
  }
  syn InhDecl TypeDecl.lookupInhDeclPrefix(String signature) {
    for(int i = 0; i < getNumInhDecl(); i++)
      if(getInhDecl(i).signature().equals(signature) || getInhDecl(i).signature().startsWith(signature + "_"))
        return getInhDecl(i);
    return null;
  }
  syn InhDecl ASTDecl.lookupInhDeclPrefix(String signature) {
    InhDecl decl = super.lookupInhDeclPrefix(signature);
    if(decl != null || superClass() == null)
      return decl;
    return superClass().lookupInhDeclPrefix(signature);
  }


  public String ASTDecl.genInhEquations() {
    StringBuffer buf = new StringBuffer();
    for(Iterator idIter = inhAttrSet(); idIter.hasNext(); ) {
      String attrId = (String)idIter.next();
      Iterator iter = inhAttrEqs(attrId);
      InhEq equ = (InhEq)iter.next();
      InhDecl decl = (InhDecl)equ.decl();

      String s;
      buf.append("    // Declared in " + equ.getFileName() + " at line " + equ.getStartLine() + "\n");
      s = "    public #TYPE# #CLASS#.Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARMDECL#) {\n";
      s = s.replaceAll("#TYPE#", decl.implType());
      s = s.replaceAll("#TYPEINSIGNATURE#", decl.getTypeInSignature());
      if(!aspectJ)
        s = s.replaceAll("#CLASS#\\.", "");
      else
        s = s.replaceAll("#CLASS#", implName());
      s = s.replaceAll("#NAME#", decl.attributeSignature());
      s = s.replaceAll("#METHODNAME#", decl.attributeName());
      s = s.replaceAll("#PARMDECL#", decl.parametersDecl());
      s = s.replaceAll("#INTERFACEPARMDECL#", decl.interfaceParametersDecl());
      buf.append(s);
      
      do {
        Components c = equ.getComponents();
        if(c instanceof ListComponents) {
          s = "        if(caller == get#NAME#ListNoTransform())";
        }
        else if(c instanceof OptionalComponent) {
          s = "        if(caller == get#NAME#OptNoTransform())";
        }
        else if(c != null) {
          s = "        if(caller == get#NAME#NoTransform())";
        }
        else if(equ.getSonName().equals("getChild")) {
          s = "        if(true)";
        }
        else {
          AttrDecl attrDecl = equ.getSonAttrDecl();
          if(attrDecl.getNumParameter() == 0)
            s = "        if(caller == #NAME#_value)";
          else
            s = "        if(caller == " + attrDecl.signature() + "_list)";
        }
        
        s = s.replaceAll("#NAME#", String.valueOf(equ.sonName()));
        if(c instanceof ListComponents) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s = s + " { \n   int " + childIndex + " = caller.getIndexOfChild(child);\n" +
                    equ.getRHS().unparse() + "\n}\n";
          }
          else { // Expr
            s = s + " {\n" + 
                  "      int " + childIndex + " = caller.getIndexOfChild(child);\n" +
                  "            return " + equ.getRHS().unparse() + ";\n" +
                  "        }\n";
          }
          
        }
        else if(c != null) {
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s = s + equ.getRHS().unparse() + "\n";
          }
          else { // Expr
            s = s + " {\n" + 
              "            return " + equ.getRHS().unparse() + ";\n" +
              "        }\n";
          }
        }
        else if(equ.getSonName().equals("getChild")) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s = s + " { \n   int " + childIndex + " = this.getIndexOfChild(caller);\n" +
                    equ.getRHS().unparse() + "\n}\n";
          }
          else { // Expr
            s = s + " {\n" + 
                  "      int " + childIndex + " = this.getIndexOfChild(caller);\n" +
                  "            return " + equ.getRHS().unparse() + ";\n" +
                  "        }\n";
          }
        }
        else {
          AttrDecl attrDecl = equ.getSonAttrDecl();
          s = s + "{\n";
          if(attrDecl.getNumParameter() != 0) {
          String childIndex = equ.hasIndex() ? equ.getIndex().getName() : "childIndex";
          s = s + "   int " + childIndex + " = caller.getIndexOfChild(child);\n";
          }
          if(equ.getRHS() instanceof ASTBlock) { // Block
            s = s + equ.getRHS().unparse() + "\n}\n";
          }
          else { // Expr
            s = s + "            return " + equ.getRHS().unparse() + ";\n" +
                    "        }\n";
          }
        }
        buf.append(s);

        if(iter.hasNext()) {
          equ = (InhEq)iter.next();
        }
        else {
          equ = null;
        }
      } while(equ != null);
      
      if(superClass() != null && superClass().hasInhEq(decl.name())) {
        s = "        return super.Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARM#);\n" + 
            "    }\n\n";
      }
      else {
        // TODO: INH
        if(!ASTNode.parentInterface)
        s = decl.inhDebugString() + 
            "        return getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + decl.interfaceParametersContinue() + ");\n" +
            "    }\n\n";
        else
        s = "        ASTNode n = getParent();\n" + 
            "        caller = this;\n" + 
            "        child = null;\n" + 
            "        while(!(n instanceof Defines_#TYPEINSIGNATURE#_#NAME#)) {\n" +
            "            child = caller;\n" + 
            "            caller = n;\n" + 
            "            n = n.getParent();\n" + 
            "        }\n" +
            decl.inhDebugString() +
            "        return ((Defines_#TYPEINSIGNATURE#_#NAME#)n).Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARM#);\n" + 
            "    }\n\n";
      }
      s = s.replaceAll("#NAME#", decl.attributeSignature());
      s = s.replaceAll("#METHODNAME#", decl.attributeName());
      s = s.replaceAll("#TYPE#", decl.implType());
      s = s.replaceAll("#TYPEINSIGNATURE#", decl.getTypeInSignature());
      s = s.replaceAll("#PARM#", decl.parameters());
      s = s.replaceAll("#INTERFACEPARM#", decl.interfaceParameters());
      buf.append(s);
    }
    return buf.toString();
  }

  public Iterator Grammar.inhAttrSet() {
    return inhEqMap().keySet().iterator();
  }

  syn lazy HashMap Grammar.inhEqMap() {
    HashMap map = new LinkedHashMap();
    for(int i = 0; i < getNumTypeDecl(); i++) {
      if(getTypeDecl(i) instanceof ASTDecl) {
        map.putAll(((ASTDecl)getTypeDecl(i)).inhEqMap());
      }
    }
    return map;
  }

  syn lazy Collection Grammar.rewriteAspects() {
    Set set = new LinkedHashSet();
    for(int i = 0; i < getNumTypeDecl(); i++) {
      if(getTypeDecl(i) instanceof ASTDecl) {
        ASTDecl decl = (ASTDecl)getTypeDecl(i);
        for(int j = 0; j < decl.getNumRewrite(); j++) {
          Rewrite r = decl.getRewrite(j);
          set.add(r.aspectName());
        }
      }
    }
    return set;
  }

  syn lazy String Rewrite.aspectName() {
    String name = getFileName();
    if(name.endsWith(".jrag"))
      name = name.substring(0, name.length() - 5);
    else if(name.endsWith(".jadd"))
      name = name.substring(0, name.length() - 5);
    else if(name.endsWith(".ast"))
      name = name.substring(0, name.length() - 4);
    return name;
  }

  public void Grammar.genResetDuringCounters(PrintWriter out) {
    for(Iterator iter = rewriteAspects().iterator(); iter.hasNext(); ) {
      String name = (String)iter.next();
      String s = 
                 "        if(during" + name + " != 0) {\n" + 
                 "            System.out.println(\"Warning: resetting during" + name + "\");\n" +
                 "            during" + name + " = 0;\n" +
                 "        }\n";
      out.print(s);
    }

  }

  public void Grammar.genRewriteOrderChecks(PrintWriter out) {
    for(Iterator iter = rewriteAspects().iterator(); iter.hasNext(); ) {
      String name = (String)iter.next();
      String s = "    protected int ASTNode$State.during" + name + " = 0;\n" +
                 "    protected boolean ASTNode.during" + name + "() {\n" + 
                 "        if(state().during" + name + " == 0) {\n" + 
                 "            return false;\n" +
                 "        }\n" + 
                 "        else {\n" + 
                 "            state().pop();\n" +
                 "            state().push(ASTNode$State.REWRITE_INTERRUPT);\n" +
                 "            return true;\n" +
                 "        }\n" + 
                 "    }\n";
      out.print(s);
    }
  }
  
    
  
  public String ASTDecl.genRewrites() {
    StringBuffer buf = new StringBuffer();
    boolean unconditional = false;
    buf.append("public ASTNode rewriteTo() {\n");
    if(name().equals(ASTNode.listName)) {
      buf.append("    if(list_touched) {\n");
      buf.append("        for(int i = 0 ; i < getNumChildNoTransform(); i++)\n");
      buf.append("            getChild(i);\n");
      buf.append("        list_touched = false;\n");
      buf.append("        return this;\n");
      buf.append("    }\n");
    }
    for(int i = 0; i < getNumRewrite(); i++) {
      Rewrite r = getRewrite(i);
      if(r.genRewrite(buf, i))
        unconditional = true;
    }
    if(name().equals("ASTNode")) {
      buf.append("    if(state().peek() == ASTNode$State.REWRITE_CHANGE) {\n");
      buf.append("        state().pop();\n");
      buf.append("        state().push(ASTNode$State.REWRITE_NOCHANGE);\n");
      buf.append("    }\n");
      buf.append("    return this;\n");
    }
    else if(!unconditional)
      buf.append("    return super.rewriteTo();\n");
    buf.append("}\n\n");
    for(int i = 0; i < getNumRewrite(); i++) {
      Rewrite r = getRewrite(i);
      r.genRewritesExtra(buf, i);
    }
    return buf.toString();
  }

  public boolean Rewrite.genRewrite(StringBuffer buf, int index) {
      buf.append("    // Declared in " + getFileName() + " at line " + getStartLine() + "\n");
      if(getCondition() != null) {
        buf.append("    if(" + getCondition().unparse() + ") {\n");
        buf.append("        state().during" + aspectName() + "++;\n");
        buf.append("        ASTNode result = rewriteRule" + index + "();\n");
        buf.append("        state().during" + aspectName() + "--;\n");
        buf.append("        return result;\n");
        buf.append("    }\n");
        
        buf.append("\n");
        return false;
      }
      else {
        buf.append("        state().during" + aspectName() + "++;\n");
        buf.append("        ASTNode result = rewriteRule" + index + "();\n");
        buf.append("        state().during" + aspectName() + "--;\n");
        buf.append("        return result;\n");
        return true;
      }
  }
  public boolean RewriteList.genRewrite(StringBuffer buf, int index) {
      buf.append("    // Declared in " + getFileName() + " at line " + getStartLine() + "\n");
      buf.append("    if(getParent().getParent() instanceof " + getParentName() + " && \n");
      buf.append("        ((" + getParentName() + ")getParent().getParent())." + getChildName() + "ListNoTransform() == getParent()");
      if(getCondition() != null) {
        buf.append(" && " + getCondition().unparse() + ") {\n");
      }
      else {
        buf.append(") {\n");
      }

      buf.append("        state().during" + aspectName() + "++;\n");
      
      buf.append("      " + ASTNode.listName + " list = (" + ASTNode.listName + ")getParent();\n");
      buf.append("      int i = list.getIndexOfChild(this);\n");
      buf.append("      " + ASTNode.listName + " newList = rewrite" + getParentName() + "_" + getChildName() + "();\n");
      // the first child is set by the normal rewrite loop
      //buf.append("      list.setChild(newList.getChildNoTransform(0), i);\n");
      buf.append("      for(int j = 1; j < newList.getNumChildNoTransform(); j++)\n");
      buf.append("        list.insertChild(newList.getChildNoTransform(j), ++i);\n");

      buf.append("        state().during" + aspectName() + "--;\n");
      
      buf.append("      return newList.getChildNoTransform(0);\n");
      buf.append("    }\n");
      return false;
  }

  public void Rewrite.genRewritesExtra(StringBuffer buf, int index) {
    buf.append("    // Declared in " + getFileName() + " at line " + getStartLine() + "\n");
    if(getResult() instanceof jrag.AST.ASTBlock) {
      buf.append("    private " + getReturnType() + " rewriteRule" + index + "() {\n");
      if(rewriteLimit > 0)
        buf.append("         debugRewrite(\"Rewriting \" + getClass().getName() + \" using rule in " + getFileName() + " at line " + getStartLine() + "\");\n");
      buf.append(getResult().unparse());
      buf.append("    }\n");
    }
    else {
      buf.append("    private " + getReturnType() + " rewriteRule" + index + "() {\n");
      if(rewriteLimit > 0)
        buf.append("         debugRewrite(\"Rewriting \" + getClass().getName() + \" using rule in " + getFileName() + " at line " + getStartLine() + "\");\n");
      buf.append("        return " + getResult().unparse() + ";\n");
      buf.append("    }\n");
    }
  }
  public void RewriteList.genRewritesExtra(StringBuffer buf, int index) {
    buf.append("    // Declared in " + getFileName() + " at line " + getStartLine() + "\n");
    if(getResult() instanceof jrag.AST.ASTBlock) {
      buf.append("    private " + getReturnType() + " rewrite" + getParentName() + "_" + getChildName() + "() {\n");
      if(rewriteLimit > 0)
        buf.append("         debugRewrite(\"Rewriting \" + getClass().getName() + \" using rule in " + getFileName() + " at line " + getStartLine() + "\");\n");
      buf.append(getResult().unparse());
      buf.append("    }\n");
    }
    else {
      buf.append("    private " + getReturnType() + " rewrite" + getParentName() + "_" + getChildName() + "() {\n");
      if(rewriteLimit > 0)
        buf.append("         debugRewrite(\"Rewriting \" + getClass().getName() + \" using rule in " + getFileName() + " at line " + getStartLine() + "\");\n");
      buf.append("        return " + getResult().unparse() + ";\n");
      buf.append("    }\n");
    }
  }
  

  public void Grammar.createInterfaces(File outputDir, String pack)
    throws FileNotFoundException {
      if(!ASTNode.parentInterface)
        return;
    for(Iterator iter = inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
      java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
      String attrId = (String)entry.getKey();
      AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
      String interfaceName;
      if(pack.equals("")) {
        interfaceName = "Defines_" + attrId;                                                                                                                      
      }                                                                                                                                                           
      else {                                                                                                                                                      
        interfaceName = pack.replace('.', File.separatorChar) + File.separator +                                                                                  
          "Defines_" + attrId;                                                                                                                                    
      }                                                                                                                                                           
      File file = new File(outputDir, interfaceName + ".java");                                                                                                   
          PrintStream p = new PrintStream(new FileOutputStream(file));                                                                                            
          if(!pack.equals("")) {                                                                                                                                  
            p.println("package " + pack + ";");                                                                                                                   
            p.println();                                                                                                                                          
          }                                                                                                                                                       
                                                                                                                                                                  
      p.print(genImportsList());                                                                                                                                  
                                                                                                                                                                  
      String s;                                                                                                                                                   
      s = "public interface Defines_#TYPEINSIGNATURE#_#NAME# {\n" +                                                                                               
          "    public #TYPE# Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARMDECL#);\n" +                                                                     
          "}\n";
      s = s.replaceAll("#TYPE#", attr.implType());
      s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
      s = s.replaceAll("#NAME#", attr.attributeSignature());
      s = s.replaceAll("#METHODNAME#", attr.attributeName());
      s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
      s = s.replaceAll("#INTERFACEPARMDECL#", attr.interfaceParametersDecl());
      p.print(s);
    }
  }

  syn lazy boolean ASTDecl.hasRewrites() = getNumRewrite() > 0 || (superClass() != null && superClass().hasRewrites());

  //  TODO: INH
  public void ASTDecl.emitInhEqSignatures(PrintStream p) {
    if(ASTNode.parentInterface)
      return;
    if(name().equals("ASTNode")) {
      for(Iterator iter = env().inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
        java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
        String attrId = (String)entry.getKey();
        AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
        if(!hasInhEq(attr.decl().name())) {
          String s =
            "    public #TYPE# Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARMDECL#) {\n" +
            attr.decl().inhDebugString() +
            "        return getParent().Define_#TYPEINSIGNATURE#_#METHODNAME#(" + attr.interfaceParametersContinue() + ");\n" +
            "    }\n";
          s = s.replaceAll("#TYPE#", attr.implType());
          s = s.replaceAll("#TYPEINSIGNATURE#", attr.getTypeInSignature());
          s = s.replaceAll("#NAME#", attr.attributeSignature());
          s = s.replaceAll("#METHODNAME#", attr.attributeName());
          s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
          s = s.replaceAll("#INTERFACEPARM#", attr.interfaceParameters());
          s = s.replaceAll("#INTERFACEPARMDECL#", attr.interfaceParametersDecl());
          p.print(s);
        }
      }
    }
    //else if(name().equals("Block") || name().equals("Binary") || name().equals("TypeDecl") || name().equals("Dot")) {
    /*
    else if(name().equals("Block")) {
      for(Iterator iter = env().inhEqMap().entrySet().iterator(); iter.hasNext(); ) {
        java.util.Map.Entry entry = (java.util.Map.Entry)iter.next();
        String attrId = (String)entry.getKey();
        AttrEq attr = (AttrEq)((LinkedList)entry.getValue()).get(0);
        if(inhAttrEqs(attrId) == null && lookupInhDecl(attr.signature()) == null && !attr.decl().isCircular()) {
          String s = genInhCache(attr.decl());
          s = s.replaceAll("#TYPE#", attr.type());
          s = s.replaceAll("#TYPEINSIGNATURE#", attr.type().replace('.', '_'));
          s = s.replaceAll("#NAME#", attr.attributeSignature());
          s = s.replaceAll("#METHODNAME#", attr.attributeName());
          s = s.replaceAll("#PARMDECL#", attr.parametersDecl());
          s = s.replaceAll("#INTERFACEPARM#", attr.interfaceParameters());
          s = s.replaceAll("#INTERFACEPARMDECL#", attr.interfaceParametersDecl());
          s = s.replaceAll("#CLASS#\\.", "");
          p.print(s);
        }
      }
    }
    */
  }
  public String ASTDecl.genInhCache(AttrDecl attr) {
      boolean isLazy = attr.getLazy();
      attr.setLazy(true);
      String s =
           attr.cacheDeclarations() + 
           "    public #TYPE# Define_#TYPEINSIGNATURE#_#METHODNAME#(#INTERFACEPARMDECL#) {\n" + 
           attr.parameterStructure() + 
           attr.initLazyMaps() +
           attr.cacheCheck() + 
           attr.cacheInit() + 
           attr.callCompute() + 
           attr.cacheStore() + 
           attr.returnStmt() + 
           "    }\n\n";
       attr.setLazy(isLazy);
       return s;
    }


  syn String AttrDecl.tracePrintReturnPreviousValue(String varName) = "";
  syn String AttrDecl.tracePrintReturnNewValue(String varName) = "";
  syn String AttrDecl.tracePrintBeginComputingValue() = "";
  syn String AttrDecl.tracePrintCycleBeginString() = "";
  syn String AttrDecl.tracePrintCycleEndString() = "";
  syn String AttrDecl.tracePrintStartingCycle() = "";
  syn String AttrDecl.traceComputeContext() = "";

  syn String AttrDecl.traceSignature() {
    StringBuilder b = new StringBuilder();
    b.append(getAspectName());
    b.append(": ");
    if(this instanceof SynDecl)
      b.append("syn ");
    if(this instanceof InhDecl)
      b.append("inh ");
    if(getLazy())
      b.append("lazy ");
    if(isCircular())
      b.append(" circular");
    
    b.append(getType());
    b.append(" ");
    b.append(hostClass().name());
    b.append(".");
    b.append(name());
    b.append("(");
    for(int i = 0; i < getNumParameter(); i++) {
      if(i != 0)
        b.append(", ");
      b.append(getParameter(i).getType());
      b.append(" ");
      b.append(getParameter(i).getName());
    }
    b.append(")");
    b.append(", ");
    b.append("this = \" + this.getClass().getName() + \"@\"+ Integer.toHexString(this.hashCode()) + \"");
    for(int i = 0; i < getNumParameter(); i++) {
      String name = getParameter(i).getName();
      String type = getParameter(i).getType();
      b.append(", ");
      b.append(name);
      b.append(" = ");
      if(isPrimitive(type) || type.equals("String") || type.equals("java.lang.String"))
        b.append("\" + " + name + " + \"");
      else
        b.append("\" + " + name + ".getClass().getName() + \"@\" + Integer.toHexString(" + name + ".hashCode()) + \"");
    }
    return b.toString();
  }

  protected String AttrDecl.trace(String s) {
    if(!tracing)
      return "";
    StringBuilder b = new StringBuilder();
    b.append("System.out.println(\"");
    b.append(s);
    b.append("\");\n");
    return b.toString();
  }

  syn String AttrDecl.traceBeginAttr() =
    trace("begin " + traceSignature());
  syn String AttrDecl.traceEndAttr() =
    trace("end " + traceSignature());
  syn String AttrDecl.traceEndCachedAttr() =
    trace("end cached " + traceSignature());


  
}
