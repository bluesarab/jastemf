import ast.AST.*;

import java.io.*;
import java.util.*;
import java.util.regex.*;

/**
 * The aspects in this file create the standard methods for every type in the AST.
 * 
 * For example, constructors, getChild() etc.
 * 
 */

aspect JaddCodeGen {
  public void Grammar.abstractAncestors() {
    ASTDecl cl;
    IdDecl name;
    
    // Add ASTNode
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID(ASTNode.nodeName);
    cl.setIdDecl(name);
    cl.setFileName(ASTNode.nodeName+".ast");
    addTypeDecl(cl);
    
    // Add List
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID(ASTNode.listName);
    cl.setIdDecl(name);
    cl.setFileName(ASTNode.listName+".ast");
    addTypeDecl(cl);

    // Add Opt
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID(ASTNode.optName);
    cl.setIdDecl(name);
    cl.setFileName(ASTNode.optName+".ast");
    addTypeDecl(cl);
  }

  syn int ASTDecl.numNonNTAComponents() {
    int num = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        num++;
      }
    }
    return num;
  }

  syn int ASTDecl.numRegularChildren() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && !(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  // Constructor to build trees bottom up
  public String ASTDecl.buildingConstructor() {
    // we only build constructors if there are components
    if(!getComponents().hasNext())
      return "";
    StringBuffer s = new StringBuffer();
    s.append("    // Declared in " + getFileName() + " line " + getStartLine() + "\n");
    s.append("    public #ID#.#ID_IMPL#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        s.append(computeImplName(c.constrParmType()) + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append("        set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append("        setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append("        setChild(new " + ASTNode.listName + "(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append("        setChild(new " + ASTNode.optName + "(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append("        setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append("        is$Final(java.lang.Integer.MAX_VALUE);\n");
      else
        s.append("        is$Final(true);\n");
    }
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append("    }\n\n");
    //JastEMF beware: TypeDecl is different from printed code
    return s.toString().replaceAll("#ID#", name()).replaceAll("#ID_IMPL#", implName());
  }

  public String ASTDecl.buildingSymbolConstructor() {
    // we only build constructors if there are components ...
    if(!getComponents().hasNext())
      return "";
    // ... and one of these components is a string token component
    boolean stringArg = false;
    for(Iterator iter = getComponents(); !stringArg && iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
        stringArg = true;
    }
    if(!stringArg) return "";

    StringBuffer s = new StringBuffer();
    s.append("    // Declared in " + getFileName() + " line " + getStartLine() + "\n");
    s.append("    public #ID#.#ID_IMPL#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        if(c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
          s.append("beaver.Symbol p" + i);
        else
          s.append(computeImplName(c.constrParmType()) + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append("        set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append("        setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append("        setChild(new " + ASTNode.listName + "(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append("        setChild(new " + ASTNode.optName +"(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append("        setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append("        is$Final(java.lang.Integer.MAX_VALUE);\n");
      else
        s.append("        is$Final(true);\n");
    }
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append("    }\n\n");
    return s.toString().replaceAll("#ID#", name()).replaceAll("#ID_IMPL#", implName());
  }

  public void Grammar.genReset(PrintWriter stream) {
    stream.println("    public void ASTNode$State.reset() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(circularEnabled) {
      stream.println("        IN_CIRCLE = false;");
      stream.println("        CIRCLE_INDEX = 1;"); // TOBBE
      stream.println("        CHANGE = false;");
      if(cacheCycle)
          stream.println("        LAST_CYCLE = false;");
      if(componentCheck) {
          stream.println("        circularEvalSet = " + ASTNode.createDefaultSet + ";");
          stream.println("        circularEvalStack = new java.util.Stack();");
      }
    }
    if(rewriteEnabled) {
      stream.println("        boundariesCrossed = 0;");
      genResetDuringCounters(stream);
      if(rewriteLimit > 0)
        stream.println("        debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      if(stagedRewrites)
        stream.println("        rewritePhase = 1;\n");
    }
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println("    }");
  }

  public void Grammar.jjtGenASTNode$State(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
      stream.println("   static public class ASTNode$State {");
      if(circularEnabled) {
         stream.println("  public boolean IN_CIRCLE = false;");
         stream.println("  public int CIRCLE_INDEX = 1;");
         stream.println("  public boolean CHANGE = false;");
         if(cacheCycle) {
            stream.println("  public boolean LAST_CYCLE = false;");
         }
         stream.println("  public boolean RESET_CYCLE = false;");

         stream.println("  static public class CircularValue {");
         stream.println("    Object value;");
         stream.println("    int visited = -1;");
         stream.println("  }");

         if(componentCheck) {
           stream.println("  public " + ASTNode.typeDefaultSet + " circularEvalSet = " + ASTNode.createDefaultSet + ";");
           stream.println("  public java.util.Stack circularEvalStack = new java.util.Stack();");

           stream.println("  static class CircularEvalEntry {");
           stream.println("  	 ASTNode node;");
           stream.println("  	 String attrName;");
           stream.println("  	 Object parameters;");

           stream.println("  	 public CircularEvalEntry(ASTNode node, String attrName, Object parameters) {");
           stream.println("  	   this.node = node;");
           stream.println("   	 this.attrName = attrName;");
           stream.println("  		 this.parameters = parameters;");
           stream.println("  	 }");

           stream.println("  	 public boolean equals(Object rhs) {");
           stream.println("  	   CircularEvalEntry s = (CircularEvalEntry) rhs;");
           stream.println("  		 if (parameters == null && s.parameters == null)");
           stream.println("  			 return node == s.node && attrName.equals(s.attrName);");
           stream.println("  		 else if (parameters != null && s.parameters != null)");
           stream.println("  			 return node == s.node && attrName.equals(s.attrName) && parameters.equals(s.parameters);");
           stream.println("  		 else");
           stream.println("  			 return false;");
           stream.println("  	 }");

           stream.println("  	 public int hashCode() {");
           stream.println("  		 return node.hashCode();");
           stream.println("  	 }");
           stream.println("  }");

           stream.println("  public void addEvalEntry(ASTNode node, String attrName, Object parameters) {");
           stream.println("    circularEvalSet.add(new CircularEvalEntry(node,attrName,parameters));");
           stream.println("  }");

           stream.println("  public boolean containsEvalEntry(ASTNode node, String attrName, Object parameters) {");
           stream.println("    return circularEvalSet.contains(new CircularEvalEntry(node,attrName,parameters));");
           stream.println("  }");

           stream.println("  static class CircularStackEntry {");
           stream.println("    " + ASTNode.typeDefaultSet + " circularEvalSet;");
           stream.println("  	 boolean changeValue;");

           stream.println("  	 public CircularStackEntry(" + ASTNode.typeDefaultSet + " set, boolean change) {");
           stream.println("  		 circularEvalSet = set;");
           stream.println("  		 changeValue = change;");
           stream.println("  	 }");
           stream.println("  }");

           stream.println("  public void pushEvalStack() {");
           stream.println("  	 circularEvalStack.push(new CircularStackEntry(circularEvalSet, CHANGE));");
           stream.println("  	 circularEvalSet = " + ASTNode.createDefaultSet + ";");
           stream.println("  	 CHANGE = false;");
           stream.println("  }");

           stream.println("  public void popEvalStack() {");
           stream.println("  	 CircularStackEntry c = (CircularStackEntry) circularEvalStack.pop();");
           stream.println("  	 circularEvalSet = c.circularEvalSet;");
           stream.println("  	 CHANGE = c.changeValue;");
           stream.println("  }");

         }
      }
      if(rewriteEnabled) {
        stream.println("  public static final int REWRITE_CHANGE = 1;");
        stream.println("  public static final int REWRITE_NOCHANGE = 2;");
        stream.println("  public static final int REWRITE_INTERRUPT = 3;");
        if(rewriteLimit > 0) {
          stream.println("  public java.util.HashMap debugRewrite = " + ASTNode.createDefaultMap + ";\n");
        }
        stream.println("  public int boundariesCrossed = 0;\n");
        if(stagedRewrites)
          stream.println("public int rewritePhase = 1;");
        // state code
        stream.println("   private int[] stack;");
        stream.println("   private int pos;");
        stream.println("   public ASTNode$State() {");
        stream.println("     stack = new int[64];");
        stream.println("     pos = 0;");
        stream.println("   }");
        stream.println("   private void ensureSize(int size) {");
        stream.println("     if(size < stack.length)");
        stream.println("       return;");
        stream.println("     int[] newStack = new int[stack.length * 2];");
        stream.println("     System.arraycopy(stack, 0, newStack, 0, stack.length);");
        stream.println("     stack = newStack;");
        stream.println("   }");
        stream.println("   public void push(int i) {");
        stream.println("     ensureSize(pos+1);");
        stream.println("     stack[pos++] = i;");
        stream.println("   }");
        stream.println("   public int pop() {");
        stream.println("     return stack[--pos];");
        stream.println("   }");
        stream.println("   public int peek() {");
        stream.println("     return stack[pos-1];");
        stream.println("   }");
      }

      if(j2me) {
        stream.println("  static class HashtableBasedSet  {");
        stream.println("    public HashtableBasedSet(int initialCapacity) {");
        stream.println("      map = new java.util.Hashtable(initialCapacity);");
        stream.println("    }");
        stream.println("    private java.util.Hashtable map;");
        stream.println("    private static final Object PRESENT = new Object();");
        stream.println("    public java.util.Enumeration elements() { return map.keys(); }");
        stream.println("    public int size() { return map.size(); }");
        stream.println("    public boolean isEmpty() { return map.isEmpty(); }");
        stream.println("    public boolean contains(Object o) { return map.containsKey(o); }");
        stream.println("    public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
        stream.println("    public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
        stream.println("    public void clear() { map.clear(); }");
        stream.println("  }");
      }
      else if(deterministic) {
        stream.println("  static class IdentityHashSet extends java.util.LinkedHashSet {");
        stream.println("    public IdentityHashSet(int initialCapacity) { super(initialCapacity); }");
        stream.println("    public java.util.Iterator iterator() {");
        stream.println("      final java.util.Iterator i = super.iterator();");
        stream.println("      return new java.util.Iterator() {");
        stream.println("        public boolean hasNext() { return i.hasNext(); }");
        stream.println("        public Object next() { return ((Wrapper)i.next()).o; }");
        stream.println("        public void remove() { i.remove(); }");
        stream.println("      };");
        stream.println("    }");
        stream.println("    public boolean contains(Object o) { return super.contains(wrap(o)); }");
        stream.println("    public boolean add(Object o) { return super.add(wrap(o)); }");
        stream.println("    public boolean remove(Object o) { return super.remove(wrap(o)); }");
        stream.println("    private Wrapper wrap(Object o) { return new Wrapper(o); }");
        stream.println("    private static class Wrapper {");
        stream.println("      private Object o;");
        stream.println("      private Wrapper(Object o) { this.o = o; }");
        stream.println("      public boolean equals(Object other) { return other instanceof Wrapper && ((Wrapper)other).o == o; }");
        stream.println("      public int hashCode() { return System.identityHashCode(o); }");
        stream.println("    }");
        stream.println("  }");
      }
      else {
        stream.println("  static class IdentityHashSet extends java.util.AbstractSet implements java.util.Set {");
        stream.println("    public IdentityHashSet(int initialCapacity) {");
        stream.println("      map = new java.util.IdentityHashMap(initialCapacity);");
        stream.println("    }");
        stream.println("    private java.util.IdentityHashMap map;");
        stream.println("    private static final Object PRESENT = new Object();");
        stream.println("    public java.util.Iterator iterator() { return map.keySet().iterator(); }");
        stream.println("    public int size() { return map.size(); }");
        stream.println("    public boolean isEmpty() { return map.isEmpty(); }");
        stream.println("    public boolean contains(Object o) { return map.containsKey(o); }");
        stream.println("    public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
        stream.println("    public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
        stream.println("    public void clear() { map.clear(); }");
        stream.println("  }");
      }

      stream.println("  }"); // End ASTNode$State
  }

  public void ASTDecl.jjtGenASTNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
      stream.println("   public static final boolean ASTNode.generatedWithCircularEnabled = " + ASTNode.circularEnabled + ";");
      stream.println("   public static final boolean ASTNode.generatedWithCacheCycle = " + ASTNode.cacheCycle + ";");
      stream.println("   public static final boolean ASTNode.generatedWithComponentCheck = " + ASTNode.componentCheck + ";");
      if(ASTNode.noStatic) {
        stream.println("    protected ASTNode$State ASTNode.state = null;");
        stream.println("    public final ASTNode$State ASTNode.state() {");
        stream.println("        if(state == null) {");
        stream.println("            if(parent == null) {");
        stream.println("                 state = new ASTNode$State();");
        if(ASTNode.debugMode) {
          // check if a new state object is created for a node that is not a root node
          StringBuffer s = new StringBuffer();
          s.append("if(");
          boolean first = true;
          for(Iterator iter = env().roots().iterator(); iter.hasNext(); ) {
            ASTDecl root = (ASTDecl)iter.next();
            if(!first)
              s.append(" && ");
            first = false;
            s.append("!(this instanceof " + root.name() + ")");
          }
          s.append(") throw new RuntimeException(\"Trying to evaluate state in a node which is not attached to the main tree\");");
          stream.println(s.toString());
        }
        stream.println("            }");
        stream.println("            else {");
        stream.println("                state = parent.state();");
        stream.println("            }");
        stream.println("        }");
        stream.println("        return state;");
        stream.println("    }");
      }
      else {
        stream.println("   protected static ASTNode$State ASTNode.state = new ASTNode$State();");
        stream.println("   public final ASTNode$State ASTNode.state() { return state; }");
      }

      if(rewriteEnabled) {
        if(rewriteLimit > 0) {
          stream.println("  public void ASTNode.debugRewrite(String info) {");
          stream.println("    if(!parent.is$Final()) return;");
          stream.println("    java.util.ArrayList key = new java.util.ArrayList(2);");
          stream.println("    key.add(getParent());");
          stream.println("    key.add(new Integer(getParent().getIndexOfChild(this)));");
          stream.println("    java.util.ArrayList list;");
          stream.println("    if(state().debugRewrite.containsKey(key))");
          stream.println("      list = (java.util.ArrayList)state().debugRewrite.get(key);");
          stream.println("    else {");
          stream.println("      list = new java.util.ArrayList();");
          stream.println("      state().debugRewrite.put(key, list);");
          stream.println("    }");
          stream.println("    list.add(info);");
          stream.println("    if(list.size() > " + rewriteLimit + ") {");
          stream.println("      StringBuffer buf = new StringBuffer(\"Iteration count exceeded for rewrite:\");");
          stream.println("      for(java.util.Iterator iter = list.iterator(); iter.hasNext(); ) buf.append(\"\\n\" + iter.next());");
          stream.println("      throw new RuntimeException(buf.toString());");
          stream.println("    }");
          stream.println("  }");
          stream.println("  public void ASTNode.debugRewriteRemove() {");
          stream.println("    java.util.ArrayList key = new java.util.ArrayList(2);");
          stream.println("    key.add(getParent());");
          stream.println("    key.add(new Integer(getParent().getIndexOfChild(this)));");
          stream.println("    state().debugRewrite.remove(key);");
          stream.println("  }\n");
        }
        stream.println("  public boolean ASTNode.in$Circle = false;");
        stream.println("  public boolean ASTNode.in$Circle() { return in$Circle; }");
        stream.println("  public void ASTNode.in$Circle(boolean b) { in$Circle = b; }");
        if(ASTNode.stagedRewrites) {
          stream.println("  public int ASTNode.is$Final = 0;");
          stream.println("  public boolean ASTNode.is$Final() { return is$Final >= state().rewritePhase; }");
          stream.println("  public void ASTNode.is$Final(int phase) { is$Final = phase; }");
          stream.println("  public void ASTNode.enterRewritePhase(int phase) { state().rewritePhase = phase; }");
          stream.println("  public boolean ASTNode.inRewritePhase(int phase) { return state().rewritePhase >= phase; }");
        }
        else {
          stream.println("  public boolean ASTNode.is$Final = false;");
          stream.println("  public boolean ASTNode.is$Final() { return is$Final; }");
          stream.println("  public void ASTNode.is$Final(boolean b) { is$Final = b; }");
        }
        if(ASTNode.java5) {
          stream.println("  @SuppressWarnings(\"cast\") public T ASTNode.getChild(int i) {");
          stream.println("    return (T)ASTNode.getChild(this, i);");
          stream.println("  }");
        }
        else {
          stream.println("  public ASTNode ASTNode.getChild(int i) {");
          stream.println("    return ASTNode.getChild(this, i);");
          stream.println("  }");
        }
        stream.println("  public static ASTNode ASTNode.getChild(ASTNode that, int i) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        stream.println("    ASTNode node = that.getChildNoTransform(i);");
        stream.println("    if(node.is$Final()) return node;");
       stream.println("    if(!node.mayHaveRewrite()) {");
        if(ASTNode.stagedRewrites)
          stream.println("      node.is$Final(that.is$Final);");
        else
          stream.println("      node.is$Final(that.is$Final());");
        stream.println("      return node;");
        stream.println("    }");
        stream.println("    if(!node.in$Circle()) {");
        stream.println("      int rewriteState;");
        stream.println("      int num = that.state().boundariesCrossed;");
        stream.println("      do {");
        stream.println("        that.state().push(ASTNode$State.REWRITE_CHANGE);");
        stream.println("        ASTNode oldNode = node;");
        stream.println("        oldNode.in$Circle(true);");
        stream.println("        node = node.rewriteTo();");
        stream.println("        if(node != oldNode)");
        stream.println("          that.setChild(node, i);");
        stream.println("        oldNode.in$Circle(false);");
        stream.println("        rewriteState = that.state().pop();");
        stream.println("      } while(rewriteState == ASTNode$State.REWRITE_CHANGE);");
        stream.println("      if(rewriteState == ASTNode$State.REWRITE_NOCHANGE && that.is$Final()) {");
        if(ASTNode.stagedRewrites)
          stream.println("        node.is$Final(that.state().rewritePhase);");
        else
          stream.println("        node.is$Final(true);");
        stream.println("        that.state().boundariesCrossed = num;");
        if(rewriteLimit > 0)
          stream.println("        node.debugRewriteRemove();");
        stream.println("      }");
        stream.println("    }");
        stream.println("    else if(that.is$Final() != node.is$Final()) that.state().boundariesCrossed++;");
        stream.println("    return node;");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");
      }
      else {
        if(ASTNode.java5) {
          stream.println("  @SuppressWarnings(\"cast\") public T ASTNode.getChild(int i) {");
          stream.println("    return (T)getChildNoTransform(i);");
          stream.println("  }");
        }
        else {
          stream.println("  public ASTNode ASTNode.getChild(int i) {");
          stream.println("    return getChildNoTransform(i);");
          stream.println("  }");
        }
      }
      stream.println("  private int ASTNode.childIndex;");
      stream.println("  public int ASTNode.getIndexOfChild(ASTNode node) {");
      stream.println("    if(node != null && node.childIndex < getNumChildNoTransform() && node == getChildNoTransform(node.childIndex))");
      stream.println("      return node.childIndex;");
      stream.println("    for(int i = 0; i < getNumChildNoTransform(); i++)");
      stream.println("      if(getChildNoTransform(i) == node) {");
      stream.println("        node.childIndex = i;");
      stream.println("        return i;");
      stream.println("      }");
      stream.println("    return -1;");
      stream.println("  }\n");
      if(ASTNode.java5)
        stream.println("  public void ASTNode.addChild(T node) {");
      else
        stream.println("  public void ASTNode.addChild(ASTNode node) {");
      stream.println("    setChild(node, getNumChildNoTransform());");
      stream.println("  }");


        if(ASTNode.java5) {
          stream.println("  @SuppressWarnings(\"cast\") public final T ASTNode.getChildNoTransform(int i) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
          stream.println("    return (T)children[i];");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
          stream.println("  }");
        }
        else {
          stream.println("  public final ASTNode ASTNode.getChildNoTransform(int i) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
          stream.println("    return (ASTNode)children[i];");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
          stream.println("  }");
        }
        stream.println("  protected int ASTNode.numChildren;"); // added
        stream.println("  protected int ASTNode.numChildren() {");
        stream.println("    return numChildren;");
        stream.println("  }");
        stream.println("  public int ASTNode.getNumChild() {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        stream.println("    return numChildren();");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");
        stream.println("  public final int ASTNode.getNumChildNoTransform() {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        stream.println("    return numChildren();");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");

        if(ASTNode.java5)
          stream.println("  public void ASTNode.setChild(T node, int i) {");
        else
          stream.println("  public void ASTNode.setChild(ASTNode node, int i) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        if(debugMode)
          stream.println("        debugNodeAttachment(node);");
        stream.println("    if(children == null) {");
        stream.println("      children = new ASTNode[i + 1];");
        stream.println("    } else if (i >= children.length) {");
        stream.println("      ASTNode c[] = new ASTNode[i << 1];");
        stream.println("      System.arraycopy(children, 0, c, 0, children.length);");
        stream.println("      children = c;");
        stream.println("    }");
        stream.println("    children[i] = node;");
        stream.println("    if(i >= numChildren) numChildren = i+1;");
        stream.println("    if(node != null) { node.setParent(this); node.childIndex = i; }");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");

        if(ASTNode.java5)
          stream.println("  public void ASTNode.insertChild(T node, int i) {");
        else
          stream.println("  public void ASTNode.insertChild(ASTNode node, int i) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        if(debugMode)
          stream.println("        debugNodeAttachment(node);");
        stream.println("    if(children == null) {");
        stream.println("      children = new ASTNode[i + 1];");
        stream.println("      children[i] = node;");
        stream.println("    } else {");
        stream.println("      ASTNode c[] = new ASTNode[children.length + 1];");
        stream.println("      System.arraycopy(children, 0, c, 0, i);");
        stream.println("      c[i] = node;");
        stream.println("      if(i < children.length)");
        stream.println("        System.arraycopy(children, i, c, i+1, children.length-i);");
        stream.println("      children = c;");
        stream.println("    }");
        stream.println("    numChildren++;");
        stream.println("    if(node != null) { node.setParent(this); node.childIndex = i; }");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");

        stream.println("  public void ASTNode.removeChild(int i) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        stream.println("    if(children != null) {");
        stream.println("      ASTNode child = (ASTNode)children[i];");
        stream.println("      if(child != null) {");
        stream.println("        child.setParent(null);");
        stream.println("        child.childIndex = -1;");
        stream.println("      }");
        stream.println("      System.arraycopy(children, i+1, children, i, children.length-i-1);");
        stream.println("      numChildren--;");
        stream.println("    }");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");

        stream.println("  public ASTNode ASTNode.getParent() {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        if(rewriteEnabled) {
          stream.println("    if(parent != null && ((ASTNode)parent).is$Final() != is$Final()) {");
          stream.println("      state().boundariesCrossed++;");
          stream.println("    }");
        }
        stream.println("    return (ASTNode)parent;");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");
        stream.println("  public void ASTNode.setParent(ASTNode node) {");
        if(ASTNode.block) stream.print(ASTNode.blockBegin);
        stream.println("    parent = node;");
        if(ASTNode.block) stream.print(ASTNode.blockEnd);
        stream.println("  }");

      if(!jjtree) {
        stream.println("  protected ASTNode ASTNode.parent;");
        stream.println("  protected ASTNode[] ASTNode.children;");
      }
      if(debugMode) {
        stream.println("    protected boolean ASTNode.debugNodeAttachmentIsRoot() { return false; }");
        stream.println("    private static void ASTNode.debugNodeAttachment(ASTNode node) {");
        stream.println("        if(node == null) throw new RuntimeException(\"Trying to assign null to a tree child node\");");
        stream.println("        while(node != null && !node.debugNodeAttachmentIsRoot()) {");
        if(rewriteEnabled)
          stream.println("            if(node.in$Circle()) return;");
        stream.println("            ASTNode parent = (ASTNode)node.parent;");
        stream.println("            if(parent != null && parent.getIndexOfChild(node) == -1) return;");
        stream.println("            node = parent;");
        stream.println("        }");
        stream.println("        if(node == null) return;");
        stream.println("        throw new RuntimeException(\"Trying to insert the same tree at multiple tree locations\");");
        stream.println("    }");
      }
  }

  public void ASTDecl.jjtGenFlushCache(PrintWriter stream) {
    stream.print("    public void flushCache() {\n");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(!name().equals("ASTNode"))
      stream.print("        super.flushCache();\n");
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq equ = getSynEq(k);
      AttrDecl attr = equ.decl();
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.print(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.print(u);
    }
    stream.print(flushCollectionCache());
    if(ASTNode.block) stream.print(ASTNode.blockEnd);

    stream.print("    }\n");
    stream.print("    public void flushCollectionCache() {\n");
    if(!name().equals("ASTNode"))
      stream.print("        super.flushCollectionCache();\n");
    stream.print(flushCollectionCache());
    stream.print("    }\n");
  }
  
  public void ASTDecl.jjtGenCloneNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    if(j2me) {
      stream.print("    public void init$copy(Object o) {\n");
      stream.print("        " + name() + " node = (" + name() + ")o;\n");
      if(name().equals("ASTNode")) {
        stream.print("        if(children != null) {\n");
        stream.print("            node.children = new ASTNode[children.length];\n");
        stream.print("            for(int i = 0; i < children.length; i++)\n");
        stream.print("                node.children[i] = children[i];\n");
        stream.print("        }\n");
      }
      else {
        stream.print("        super.init$copy(o);\n");
      }

      for(Iterator iter = getClassBodyDecls(); iter.hasNext(); ) {
        ClassBodyObject o = (ClassBodyObject)iter.next();
        jrag.AST.SimpleNode n = o.node;
        if(n instanceof jrag.AST.ASTAspectFieldDeclaration) {
          jrag.AST.Token t2 = ((jrag.AST.SimpleNode)n.jjtGetChild(1)).firstToken;
          String name = t2.image;
          StringBuffer buf = new StringBuffer();
          n.unparseClassBodyDeclaration(buf, name(), aspectJ);
          String field = buf.toString();
          if(field.indexOf("static") == -1 && field.indexOf("final") == -1)
            stream.print("        node." + name + " = " + name + ";\n");
        }
      }


    }
    else if(ASTNode.java5) {
      // covariant return type when using Java 5
      String name = implName();
      if(ASTNode.isBuiltInType(name))
        name = name + "<T>";
      stream.print("    " + ASTNode.suppressWarnings() + " public " + name + " clone() throws CloneNotSupportedException {\n");
    }
    else
      stream.print("    " + ASTNode.suppressWarnings() + " public Object clone() throws CloneNotSupportedException {\n");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);

    if(!j2me)
      stream.print("        " + implName() + " node = (" + implName() + ")super.clone();\n");

    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq equ = getSynEq(k);
      AttrDecl attr = equ.decl();
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }

    if(ASTNode.rewriteEnabled) {
      stream.print("        node.in$Circle(false);\n");
      if(ASTNode.stagedRewrites)
        stream.print("        node.is$Final(0);\n");
      else
        stream.print("        node.is$Final(false);\n");
    }

    if(!j2me)
      stream.print("        return node;\n");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.print("    }\n");
    
    if(!hasAbstract()) {
      String copyBody;
      if(j2me) {
        copyBody =
          "      #CLASS# node = new #CLASS#();\n" +
          "      this.init$copy(node);\n" +
          "      return node;\n";
      }
      else {
        copyBody =
          "      try {\n" +
          "          #CLASS# node = (#CLASS#)clone();\n" +
          "          if(children != null) node.children = (ASTNode[])children.clone();\n" +
          "          return node;\n" +
          "      } catch (CloneNotSupportedException e) {\n" +
          "      }\n" +
          "      System.err.println(\"Error: Could not clone node of type \" + getClass().getName() + \"!\");\n" +
          "      return null;\n";
      }

      String s = "    #ANNOTATIONS# public #RETURN# copy() {\n" + 
          (ASTNode.block ? ASTNode.blockBegin : "") +
          copyBody +
          (ASTNode.block ? ASTNode.blockEnd : "") +
          "    }\n" +
          "    #ANNOTATIONS# public #RETURN# fullCopy() {\n" + 
          (ASTNode.block ? ASTNode.blockBegin : "") +
          "        #ID# res = (#ID#)copy();\n" +
          "        for(int i = 0; i < getNumChildNoTransform(); i++) {\n" + 
          "          ASTNode node = getChildNoTransform(i);\n" +
          "          if(node != null) node = node.fullCopy();\n" +
          "          res.setChild(node, i);\n" +
          "        }\n" +
          "        return res;\n    }\n" +
          (ASTNode.block ? ASTNode.blockEnd : "");

      String returnName = implName();
      if(ASTNode.isBuiltInType(name()))
        returnName = returnName + "<T>";
      s = s.replaceAll("#RETURN#", ASTNode.java5 ? returnName : "ASTNode");
      s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
      s = s.replaceAll("#CLASS#", implName());
      s = s.replaceAll("#ID#", implName());
      stream.print(s);
    }
  }
  
  public void ASTDecl.jjtGenCheckTreeStructure(PrintWriter stream) {
    stream.println("public void " + name() + ".jjtAddChild(Node n, int i) {");
    stream.println("  checkChild(n, i);");
    if(name().equals("ASTNode")) {
      stream.println("  if(i >= numChildren) numChildren = i+1;");
    }
    stream.println("  super.jjtAddChild(n, i);");
    stream.println("}\n");
    if(name().equals("Opt")) {
      stream.println("public void Opt.checkChild(Node n, int i) {");
      stream.println("  if(i > 0) throw new Error(\"Optional nodes can only have one child\");");
      stream.println("  if(!(n instanceof ASTNode)) throw new Error(\"Node type must be an instance of ASTNode\");");
      stream.println("}\n");
    }
    else if(name().equals("List")) {
      stream.println("public void List.checkChild(Node n, int i) {");
      stream.println("  if(!(n instanceof ASTNode)) throw new Error(\"The node type of child \" + i + \" must be an instance of ASTNode\");");
      stream.println("}\n");
    }
    else {
      int j = 0;
      stream.println("public void " + name() + ".checkChild(Node n, int i) {");
      for(Iterator iter = getComponents(); iter.hasNext(); ) {
        Components c = (Components)iter.next();
        c.jjtGenCheckTreeStructure(stream, j);
        if(!(c instanceof TokenComponent)) {
          j++;
        }
      }
      stream.println("}\n");
    }
  }
  public void Components.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
  }
  public void ListComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println("  if(i == " + j + ") {");
    stream.println("    if(!(n instanceof List))" + 
        " throw new Error(\"Child number " + j + " of " + hostClass().name() + 
        " has the type \" + n.getClass().getName() + \" which is not an instance of List\");");
    stream.println("    for(int k = 0; k < ((List)n).getNumChildNoTransform(); k++)");
    stream.println("      if(!(((List)n).getChildNoTransform(k) instanceof " + type() + "))" + 
        " throw new Error(\"Child number \" + k + \" in " + name() + "List" + 
        " has the type \" + ((List)n).getChildNoTransform(k).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println("  }");
  }
  public void OptionalComponent.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println("  if(i == " + j + ") {");
    stream.println("    if(!(n instanceof Opt))" + 
        " throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of Opt\");");
    stream.println("    if(((Opt)n).getNumChildNoTransform() != 0 && !(((Opt)n).getChildNoTransform(0) instanceof " + type() + "))" +
        " throw new Error(\"Optional " + name() + 
        " has the type \" + ((Opt)n).getChildNoTransform(0).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println("  }");
  }
  public void AggregateComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println("  if(i == " + j + " && !(n instanceof " + type() + ")) " + 
        " throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of " + type() + "\");");
  }
  
  public void ASTDecl.jjtGenDumpTree(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    StringBuffer sb = new StringBuffer();
    sb.append("    public void " + name() + ".dumpTree(String indent, java.io.PrintStream pStream) {\n" + 
        "        pStream.println(indent + \"" + name() + "\"");
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof TokenComponent) {
        TokenComponent t = (TokenComponent)c;
        String id = t.getTokenId().getID();
        sb.append("+ \"\\\"\" + get" + id + "() + \"\\\"\"");
      }
    }
    sb.append(");\n        String childIndent = indent + \"  \";\n" + 
        "        for(int i = 0; i < getNumChild(); i++)\n" + 
        "            getChild(i).dumpTree(childIndent, pStream);\n" +
        "    }\n");
    stream.println(sb.toString());
  }
  
  public void ASTDecl.jjtGenVisitor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println("    public Object " + name() + ".jjtAccept(" + parserName + "Visitor visitor, Object data) {\n" +
          "        return visitor.visit(this, data);\n" + 
          "    }\n");
  }
  
  public void ASTDecl.jjtGenConstructor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String finalInit = "";
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        finalInit = "        is$Final(state().rewritePhase);\n";
      else
        finalInit = "        is$Final(true);\n";
    }
    stream.println("    // Declared in " + getFileName() + " line " + getStartLine() + "\n");
    String s;
    if(jjtree) {
      s = "    public #ID#.#I_IMPLD#(int i) {\n" +
          "        super(i);\n" + finalInit +
          "    }\n" +
          "    public #ID#.#ID_IMPL#(" + parserName + " p, int i) {\n" +
          "        this(i);\n" +
          "        parser = p;\n" + finalInit +
          "    }\n" +
          "    public #ID#.#ID_IMPL#() {\n" + 
          "        this(0);\n" + 
          "#NTA#";
    }
    else {
      s = "    public #ID#.#ID_IMPL#() {\n" + // L�gg till null f�r agg, tom lista f�r list, false f�r opt
          "        super();\n" + 
          "#NTA#";
    }
    String t = new String();
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponentsNTA) {
        //t = t + "        setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof OptionalComponentNTA) {
        //t = t + "        setChild(new Opt(), " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof AggregateComponentsNTA) {
        //t = t + "        setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
    }
    s = s.replaceAll("#ID#", name());
    s = s.replaceAll("#ID_IMPL#", implName());
    s = s.replaceAll("#NTA#", t);
    stream.println(s);
    // Initialize node
    i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponents) {
        stream.println("        setChild(new " + ASTNode.listName + "(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof OptionalComponent) {
        stream.println("        setChild(new " + ASTNode.optName + "(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof AggregateComponents) {
        //stream.println("        setChild(null, " + String.valueOf(i) + ");");
        i++;
      }
    }
    stream.println(finalInit);
    stream.println("    }\n");

    if(numNonNTAComponents() != 0) {
      stream.print(buildingConstructor());
      if(ASTNode.beaver)
        stream.print(buildingSymbolConstructor());
    }
    
    if(ASTNode.isBuiltInOpt(name())) {
      if(ASTNode.java5)
        stream.println("     public " + ASTNode.optName + "." + ASTNode.optName + "(T opt) {");
      else
        stream.println("     public " + ASTNode.optName + "." + ASTNode.optName + "(ASTNode opt) {");
      stream.println("         setChild(opt, 0);");
      stream.println("     }\n");
    }

  }
  
  public void ASTDecl.jjtGen(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String s;

    jjtGenConstructor(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenCloneNode(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenFlushCache(stream);
    if(jjtree) {
      jjtGenDumpTree(stream, parserName, jjtree, rewriteEnabled);
      jjtGenVisitor(stream, parserName, jjtree, rewriteEnabled);
      try {
        jjtGenCheckTreeStructure(stream);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    
    // Generate code common for all nodes by adding them to ASTNode
    if(name().equals("ASTNode")) {
      jjtGenASTNode(stream, parserName, jjtree, rewriteEnabled);
      env().genRewriteOrderChecks(stream);
      env().genReset(stream);
      if(ASTNode.java5) {
        stream.println("    public java.util.Iterator<T> ASTNode.iterator() {");
        if(ASTNode.block) stream.append(ASTNode.blockBegin);
        stream.println("        return new java.util.Iterator<T>() {");
        stream.println("            private int counter = 0;");
        stream.println("            public boolean hasNext() {");
        stream.println("                return counter < getNumChild();");
        stream.println("            }");
        stream.println("            @SuppressWarnings(\"unchecked\") public T next() {");
        stream.println("                if(hasNext())");
        stream.println("                    return (T)getChild(counter++);");
        stream.println("                else");
        stream.println("                    return null;");
        stream.println("            }");
        stream.println("            public void remove() {");
        stream.println("                throw new UnsupportedOperationException();");
        stream.println("            }");
        stream.println("        };");
        if(ASTNode.block) stream.append(ASTNode.blockEnd);
        stream.println("    }");
      }
    }
    else if(name().equals("List")) {
      if(ASTNode.java5)
        stream.println("     public List<T> List.add(T node) {");
      else
        stream.println("     public List List.add(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      if(debugMode) {
        stream.println("        if(node instanceof List)");
        stream.println("            throw new RuntimeException(\"Lists can not have children of type List\");");
        stream.println("        if(node instanceof Opt)");
        stream.println("            throw new RuntimeException(\"Lists can not have children of type Opt\");");
      }
      stream.println("          addChild(node);");
      stream.println("          return this;");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println("     }\n");
      if(ASTNode.java5)
        stream.println("     public void List.insertChild(T node, int i) {");
      else
        stream.println("     public void List.insertChild(ASTNode node, int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println("          list_touched = true;");
      stream.println("          super.insertChild(node, i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println("     }");
      if(ASTNode.java5)
        stream.println("     public void List.addChild(T node) {");
      else
        stream.println("     public void List.addChild(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println("          list_touched = true;");
      stream.println("          super.addChild(node);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println("     }");
      stream.println("     public void List.removeChild(int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println("          list_touched = true;");
      stream.println("          super.removeChild(i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println("     }");
      stream.println("     public int List.getNumChild() {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println("          if(list_touched) {");
      stream.println("              for(int i = 0; i < getNumChildNoTransform(); i++)");
      stream.println("                  getChild(i);");
      stream.println("              list_touched = false;");
      stream.println("          }");
      stream.println("          return getNumChildNoTransform();");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println("     }");
      stream.println("     private boolean List.list_touched = true;");
    }
    else if(name().equals("Opt")) {
      // do not override getNumChild with implementation below
    }
    else {
      
      if(jjtree) {
        stream.println("  public int " + name() + ".getNumChild() {");
        stream.println("    return " + numRegularChildren() + ";");
        stream.println("  }");
      }
      else {
        stream.println("  protected int " +name() + ".numChildren() {");
        stream.println("    return " + numRegularChildren() + ";");
        stream.println("  }");
      }
      if(debugMode && isRootNode()) {
        stream.println("    protected boolean " + name() + ".debugNodeAttachmentIsRoot() { return true; }");
      }
    }
    if(rewriteEnabled) {
      stream.println("    public boolean " + name() + ".mayHaveRewrite() {");
      if(name().equals("List"))
        stream.println("        return true;");
      else if(!hasRewrites())
        stream.println("        return false;");
      else if(!stagedRewrites || rewriteWithNoPhaseCondition())
        stream.println("        return true;");
      else {
        for(Iterator iter = rewritePhaseConditions().iterator(); iter.hasNext(); ) {
          String condition = (String)iter.next();
          stream.println("        if(" + condition + ") return true;");
        }
        stream.println("        return false;");
      }
      stream.println("    }");
    }
  }

  syn boolean ASTDecl.rewriteWithNoPhaseCondition() {
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() == null)
       return true;
      String condition = getRewrite(i).getCondition().unparse();
      if(condition.indexOf("inRewritePhase") == -1 && condition.indexOf("inExactRewritePhase") == -1)
        return true;
    }
    return superClass() instanceof ASTDecl && ((ASTDecl)superClass()).rewriteWithNoPhaseCondition();
  }

  syn java.util.Set ASTDecl.rewritePhaseConditions() {
    java.util.Set set = new java.util.LinkedHashSet();
    Pattern p = Pattern.compile("inRewritePhase\\(\\w*\\)|inExactRewritePhase\\(\\w*\\)");
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() != null) {
        String condition = getRewrite(i).getCondition().unparse();
        Matcher m = p.matcher(condition);
        while(m.find()) {
          String match = m.group();
          set.add(match);
        }
      }
    }
    if(superClass() instanceof ASTDecl)
      set.addAll(((ASTDecl)superClass()).rewritePhaseConditions());
    return set;
  }

  public abstract void Components.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl);

  public void ListComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String s;
    String name = decl.name();
    // Generate getNum- and get-method for the list component
    s = "    // Declared in " + hostClass().getFileName() + " line " + hostClass().getStartLine() + "\n" +
        "    public void #HOST#.set#NAME#List(#LISTTYPE# list) {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        setChild(list, #INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        //"    private int #HOST#.getNum#NAME# = 0;\n" +
        "    public int #HOST#.getNum#NAME#() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return get#NAME#List().getNumChild();\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        "    #ANNOTATIONS# public #TYPE# #HOST#.get#NAME#(int i) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#TYPE#)get#NAME#List().getChild(i);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    public void #HOST#.add#NAME#(#TYPE# node) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        #LISTTYPE# list = (parent == null || state == null) ? get#NAME#ListNoTransform() : get#NAME#List();\n" +
        "        list.addChild(node);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    public void #HOST#.add#NAME#NoTransform(#TYPE# node) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        #LISTTYPE# list = get#NAME#ListNoTransform();\n" +
        "        list.addChild(node);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    public void #HOST#.set#NAME#(#TYPE# node, int i) {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        #LISTTYPE# list = get#NAME#List();\n" +
        "        list.setChild(node, i);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n";
    if(ASTNode.java5) {
      s = s +
        "    public #LISTTYPE# #HOST#.get#NAME#s() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return get#NAME#List();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n" +
        "    public #LISTTYPE# #HOST#.get#NAME#sNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return get#NAME#ListNoTransform();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n";
    }
    if(!isNTA()) {
      s = s +
        "    #ANNOTATIONS# public #LISTTYPE# #HOST#.get#NAME#List() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        #LISTTYPE# list = (#LISTTYPE#)getChild(#INDEX#);\n" +
        "        list.getNumChild();\n" +
        "        return list;\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    #ANNOTATIONS# public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n";
    }
    else {
      s = s +
        "    public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        "    protected int #HOST#.get#NAME#ListChildPosition() {\n" +
        "        return #INDEX#;\n" +
        "    }\n\n";
    }
    s = s.replaceAll("#LISTTYPE#", ASTNode.java5 ? "List<" + computeImplName(getId().type()) + ">" : "List");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", computeImplName(getId().type()));
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll("    public ", "    private ");
    //stream.println(s);
    parse(s);
  }

  public void OptionalComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate has- and get-method for the optional component
    s = "    // Declared in " + hostClass().getFileName() + " line " + hostClass().getStartLine() + "\n" +
        "    public void #HOST#.set#NAME#Opt(#OPTTYPE# opt) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        setChild(opt, #INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    public boolean #HOST#.has#NAME#() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return get#NAME#Opt().getNumChild() != 0;\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        "    #ANNOTATIONS# public #TYPE# #HOST#.get#NAME#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#TYPE#)get#NAME#Opt().getChild(0);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        get#NAME#Opt().setChild(node, 0);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n";
    if(!isNTA()) {
      s = s +
        "    #ANNOTATIONS# public #OPTTYPE# #HOST#.get#NAME#Opt() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#OPTTYPE#)getChild(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        "    #ANNOTATIONS# public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n";
    }
    else {
        s = s + "    #ANNOTATIONS# public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        "    protected int #HOST#.get#NAME#OptChildPosition() {\n" +
        "        return #INDEX#;\n" +
        "    }\n\n";
    }
    s = s.replaceAll("#OPTTYPE#", ASTNode.java5 ? "Opt<" + computeImplName(getId().type()) + ">" : "Opt");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", computeImplName(getId().type()));
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll("    public ", "    private ");
    //stream.println(s);
    parse(s);
  }


  private boolean TokenComponent.called = false;
  public void TokenComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    StringBuffer buf = new StringBuffer();
    buf.append("    // Declared in " + hostClass().getFileName() + " line " + hostClass().getStartLine() + "\n");
    if(decl.redefinesTokenComponent(this)) {
        buf.append("    protected #TYPE# #HOST#.token#TYPEINSIGNATURE#_#ID#;\n");
    }
    // Generate attribute, get- and set-method for the token string
    buf.append(
        "    public void #HOST#.set#ID#(#TYPE# value) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        token#TYPEINSIGNATURE#_#ID# = value;\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n"
    );
    if(!isNTA()) {
      boolean isStringToken = getTokenId().getTYPE().equals("String") || getTokenId().getTYPE().equals("java.lang.String");
      if(isStringToken && ASTNode.beaver) {
        if(decl.redefinesTokenComponent(this)) {
          buf.append(
          "    public int #HOST#.#ID#start;\n" +
          "    public int #HOST#.#ID#end;\n"
          );
        }
        buf.append(
        "    public void #HOST#.set#ID#(beaver.Symbol symbol) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        if(symbol.value != null && !(symbol.value instanceof String))\n" +
        "          throw new UnsupportedOperationException(\"set#ID# is only valid for String lexemes\");\n" +
        "        token#TYPEINSIGNATURE#_#ID# = (String)symbol.value;\n" +
        "        #ID#start = symbol.getStart();\n" +
        "        #ID#end = symbol.getEnd();\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n"
        );
      }
      if(isStringToken)
        buf.append(
        "    public #TYPE# #HOST#.get#ID#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return token#TYPEINSIGNATURE#_#ID# != null ? token#TYPEINSIGNATURE#_#ID# : \"\";\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n");
      else
        buf.append(
        "    public #TYPE# #HOST#.get#ID#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return token#TYPEINSIGNATURE#_#ID#;\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n");
    }
    String s = buf.toString();
    s = s.replaceAll("#ID#", getTokenId().getID());
    s = s.replaceAll("#TYPE#", getTokenId().getTYPE());
    s = s.replaceAll("#TYPEINSIGNATURE#", ASTNode.convTypeNameToSignature(getTokenId().getTYPE()));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll("    public ", "    private ");
    //stream.println(s);
    parse(s);

  }

  public void AggregateComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate get-method for component
    s = "    // Declared in " + hostClass().getFileName() + " line " + hostClass().getStartLine() + "\n" +
        "    public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        setChild(node, #INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n";
    if(!isNTA()) {
      s = s +
        "    public #TYPE# #HOST#.get#NAME#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#TYPE#)getChild(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" + 
        "    public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n";
    }
    else {
        s = s + "    public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        "        return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        "    }\n\n" +
        "    protected int #HOST#.get#NAME#ChildPosition() {\n" +
        "        return #INDEX#;\n" +
        "    }\n\n";
    }
    s = s.replaceAll("#TYPE#", computeImplName(getId().type()));
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll("    public ", "    private ");
    //stream.println(s);
    parse(s);
  }

  protected void Components.parse(String s) {
    jrag.AST.JragParser jp = new jrag.AST.JragParser(new java.io.StringReader(s));
    jp.root = hostClass().env();
    jp.setFileName(hostClass().getFileName());
    try {
      while(true)
        jp.AspectBodyDeclaration();
    } catch (Exception e) {
    }
  }
}
