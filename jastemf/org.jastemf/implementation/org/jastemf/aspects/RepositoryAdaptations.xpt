«REM»
	This program and the accompanying materials are made available under the
	terms of the BSD 3-clause license which accompanies this distribution.
«ENDREM»
«EXTENSION org::jastemf::aspects::io»
«IMPORT ecore»
«IMPORT genmodel»

«REM»
	Template to generate integration artifacts, that perform AST structure
	repository adaptations.
	@author C. Bürger
«ENDREM»
«DEFINE Main(String astPackage, String outPackage) FOR GenModel»
«FILE asDirectory(outPackage) + "RepositoryAdaptations.jrag"-»
/**
 * Generated by JastEMF [«timeStamp()»]
 */
import org.eclipse.emf.common.util.*;
import org.eclipse.emf.ecore.*;

«FOREACH genPackages AS genPackage-»
import «genPackage.ecorePackage()».*;
import «astPackage».*;
«IF genPackage.interfacePackageSuffix != null-»
import «qualifiedPackage(genPackage, genPackage.interfacePackageSuffix)».*;
«ENDIF-»
«IF genPackage.classPackageSuffix != null-»
import «qualifiedPackage(genPackage, genPackage.classPackageSuffix)».*;
«ENDIF-»
«ENDFOREACH-»

/**
 * Aspect, that adapt's the generated <i>JastAdd</i> evaluator to use instead
 * of its AST structure repository the one of the generated <i>EMF</i> model
 * implementation. Thus, the generated JastAdd repository becomes dispensable
 * and is not used anymore.
 * @author C. Bürger
 */
aspect RepositoryAdaptations {
	/* 
	 * Support mappings from JastAdd child indexes to EMF model access methods.
	 */
	
	/**
	 * An instance of this class represents the access methods associated with
	 * an <i>EMF</i> model element's containment-element. Using a mapping from
	 * child indexes to {@link IAccessProceed access object instances} a
	 * generated <i>JastAdd</i> evaluator's AST access methods can be delegated
	 * to appropriate <i>EMF</i> model access methods.
	 * @author C. Bürger
	 * @param <T> The adapted AST node's type parameter.
	 */
	public interface IAccessMethods {
		/**
		 * Execute the model element's get method to retrieve its value.
		 * If the model element is an <tt>EList</tt> <tt>L</tt> a
		 * <i>JastAdd</i> list backed by <tt>L</tt> is returned. If the model
		 * element <tt>O</tt> represents an optional <i>JastAdd</i> child, a
		 * <i>JastAdd</i> optional backed by <tt>O</tt> is returned.
		 * @return The value of the <i>EMF</i> model element this object
		 * accesses.
		 */
		ASTNode getChild();
		/**
		 * Execute the model element's set method to set its value. If the
		 * model element represents a <i>JastAdd</i> list -- thus, the given
		 * new value must be a <i>JastAdd</i> list <tt>L</tt> -- the content
		 * of the model element's <tt>EList</tt> will be replaced by the
		 * content of <tt>L</tt>. If the model element represents a
		 * <i>JastAdd</i> optional -- thus, the given new value must be a
		 * <i>JastAdd</i> optional <tt>O</tt> -- <tt>O's</tt> content is the
		 * model element's new value.
		 * @param newValue The model element's new value.
		 */
		void setChild(ASTNode newValue);
	}
	
	/**
	 * Map the given <i>JastAdd</i> AST node child index to its associated
	 * <i>EMF</i> model element access methods. This method must be implemented
	 * for each AST node, that introduces additional children to the ones
	 * already inherited.
	 * @param index Index of the child for which to find its access methods.
	 * @return The associated access methods or <tt>null</tt> iff such a child
	 * does not exist.
	 */
	public IAccessMethods ASTNode.resolveAccess(final int index) {
		return null;
	}
	
	/*
	 * Replace JastAdd AST repository access methods by access
	 * methods that delegate to the EMF model's ones.
	 */
	
	/**
	 * Get the requested child by calling its <i>EMF</i> model access method.
	 * @param i The child's index.
	 * @return The child, iff it exists.
	 * @throws IndexOutOfBoundsException Thrown, iff the child does not exist.
	 */
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public final ASTNode ASTNode.getChildNoTransform(int i) {
		IAccessMethods getter = resolveAccess(i);
		if (getter == null)
			throw new IndexOutOfBoundsException();
		return getter.getChild();
	}
	
	/**
	 * Set a child by calling its <i>EMF</i> model access method.
	 * @param node The child to set.
	 * @param i The child's index.
	 * @throws IndexOutOfBoundsException Thrown, iff the child does not exist.
	 */
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public void ASTNode.setChild(T node, int i) {
		IAccessMethods setter = resolveAccess(i);
		if (setter == null)
			throw new IndexOutOfBoundsException();
		setter.setChild(node);
	}
	
	/**
	 * Insert a child by calling its <i>EMF</i> model access method.
	 * @param node The child to insert.
	 * @param i The child's index.
	 * @throws IndexOutOfBoundsException Thrown, iff the child does not exist.
	 */
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public void ASTNode.insertChild(T node, int i) {
		if (!(this instanceof List))
			throw Exceptions.illegalInsert(this, i, node);
		List delegator = (List)this;
		delegator.delegatee.add(i, node);
		if (node != null)
			node.childIndex = i;
		for (int ii = i + 1; i < delegator.delegatee.size(); ii++) {
			ASTNode shifted = (ASTNode)delegator.delegatee.get(ii);
			if (shifted != null)
				shifted.childIndex = ii;
		}
	}
	
	/**
	 * Remove a child by calling its <i>EMF</i> model access method.
	 * @param i The child's index.
	 * @throws IndexOutOfBoundsException Thrown, iff the child does not exist.
	 */
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public void ASTNode.removeChild(int i) {
		if (!(this instanceof List))
			throw Exceptions.illegalRemove(this, i);
		List delegator = (List)this;
		ASTNode child = getChildNoTransform(i);
		if (child != null)
			child.childIndex = -1;
		delegator.delegatee.remove(i);
		for (int ii = i; ii < delegator.delegatee.size(); ii++) {
			ASTNode shifted = (ASTNode)delegator.delegatee.get(ii);
			if (shifted != null)
				shifted.childIndex = ii;
		}
	}
	
	/*
	 * Adapt JastAdd lists and optionals to delegate accesses to model lists
	 * and element access methods respectively.
	 */
	
	/**
	 * Associate with each <i>JastAdd</i> list <tt>JL</tt> an <tt>EList</tt>
	 * <tt>ML</tt> of the model repository which represents <tt>JL's</tt>
	 * content. Thus, <tt>JL</tt> is backed by <tt>ML</tt> and delegates all
	 * its accesses to <tt>ML</tt>.
	 */
	public EList List.delegatee = new BasicEList();
	
	/**
	 * The {@link IAccessMethods access methods} for a <i>JastAdd</i> list's
	 * children are the ones of the <i>EMF</i> model's <tt>EList</tt> by which
	 * the <i>JastAdd</i> list is backed. Thus, any access to the list must be
	 * delegated to its {@link List#delegatee associated <tt>EList</tt>}.
	 * @param index The index of the list child to access.
	 * @return The backing <tt>EList's</tt> access methods.
	 */
	public IAccessMethods List.resolveAccess(final int index) {
		return new IAccessMethods() {
			public ASTNode getChild() {
				return (ASTNode)delegatee.get(index);
			}
			public void setChild(ASTNode node) {
				if (index < delegatee.size()) {
					delegatee.set(index, node);
				} else if (index == delegatee.size()) {
					delegatee.add(node);
				} else {
					final int numToAdd = index + 1 - delegatee.size();
					java.util.Collection toAdd =
						new java.util.ArrayList(numToAdd);
					for (int i = 1; i < numToAdd; i++)
						toAdd.add(null);
					toAdd.add(node);
					delegatee.addAll(toAdd);
				}
				if (node != null)
					node.childIndex = index;
			}
		};
	}
	
	/**
	 * Associate with each <i>JastAdd</i> optional <tt>JO</tt> an element
	 * <tt>MO</tt> of the model repository which represents <tt>JO's</tt>
	 * content. Thus, <tt>JO</tt> is backed by <tt>MO</tt> and delegates all
	 * its accesses to <tt>MO</tt>.
	 */
	public IAccessMethods Opt.delegatee = new IAccessMethods() {
		private ASTNode value = null;
		public ASTNode getChild() {return value;}
		public void setChild(ASTNode node) {
			this.value = node;
			if (node != null)
				node.childIndex = 0;
		}
	};
	
	/**
	 * The {@link IAccessMethods access methods} for a <i>JastAdd</i>
	 * optional's content are the ones of the <i>EMF</i> model element the
	 * optional wraps. Thus, any access to the optional must be delegated to
	 * its {@link Opt#delegatee associated element}.
	 * @param index The index of the optional's child to access. Iff the index
	 * is greater than 0 or the optional is not setted, i.e. has no value, any
	 * access to its content will result in an exception as known from
	 * <i>JastAdd</i>.
	 * @return The backing element's access methods.
	 */
	public IAccessMethods Opt.resolveAccess(final int index) {
		if (index != 0)
			throw new IndexOutOfBoundsException();
		return delegatee;
	}
	
	/* 
	 * Implement each AST node's "child index to model element" map.
	 * 
	 * REMARK: AST nodes' "resolveAccess" methods -- which realize the mapping
	 * 	from child indexes to their associated EMF model element access
	 * 	methods -- must be woven into the evaluator after its generation and
	 * 	refactoring. Otherwise, the model element access method calls within
	 * 	"resolveAccess" methods would be erroneously renamed, since EMF and
	 * 	JastAdd access methods' signatures are equal before the refactorings.
	 */
	
«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
«IF !genClass.ecoreClass.interface-»
«LET genClass.ecoreClass.eReferences.select(e|e.containment) AS localChildren-»
«LET genClass.ecoreClass.eAllContainments.select(e|!localChildren.contains(e)) AS inheritedChildren-»
«IF localChildren.size > 0-»
	private final IAccessMethods[] «genClass.ecoreClass.name».resolve_access_cache =
		new IAccessMethods[«localChildren.size»];
	@«outPackage».JastEMFAnnotations.MutatingMethod(
			  "	if (index - «inheritedChildren.size» >= 0 && resolve_access_cache[index - «inheritedChildren.size»] != null)"
			+ "		return resolve_access_cache[index - «inheritedChildren.size»];"
			+ "	switch (index) {"
«FOREACH localChildren AS child-»
			+ "	case «inheritedChildren.size + localChildren.indexOf(child)»:"
			+ "		«IF localChildren.indexOf(child) == 0-»IAccessMethods «ENDIF-»access = new IAccessMethods() {"
«IF child.upperBound == -1-»
«REM»
	The child is a list. We have to do a double dispatch:
	Getter: ECore classes with a list element E must return a JastAdd
		"List" L if "getChild(indexOfList)" is called. On the other hand,
		JastAdd lists must return the content of their backing EList if
		their children are accessed.
	Setter: ECore classes with a list element E must set the given lists's
		content as E's content if "setChild(list, indexOfList)" is called.
		Additionally, they must insert the given list into the AST -- i.e.
		specify "setParent" and "childIndex" of the list. On the other hand,
		JastAdd lists must set their backing lists content if their children
		are setted.
«ENDREM-»
			+ "			private ASTList list = new ASTList() {"
			+ "					{"
			+ "						parent = «genClass.ecoreClass.name»Impl.this;"
			+ "						childIndex = «localChildren.indexOf(child)»;"
			+ "						delegatee = get«child.name.toFirstUpper()»();"
			+ "					}"
			+ "				};"
			+ "			public ASTNode getChild() {"
			+ "				return list;"
			+ "			}"
			+ "			public void setChild(ASTNode node) {"
			+ "				ASTList newList = (ASTList)node;"
			+ "				list = newList;"
			+ "				EList elist = get«child.name.toFirstUpper()»();"
			+ "				elist.clear();"
			+ "				elist.addAll(newList.delegatee);"
			+ "				newList.parent = «genClass.ecoreClass.name»Impl.this;"
			+ "				newList.childIndex = index;"
			+ "				newList.delegatee = elist;"
			+ "			}"
«ELSE-»
«IF child.lowerBound == 0-»
«REM»
	The child is an optional. We have to do a double dispatch, similar to the
	one done for lists. The only difference is, that the delegatee of JastAdd
	optionals is not an EList, but rather an access object, which encapsulates
	the access methods of the backing model element.
«ENDREM-»
			+ "			private Opt opt = new Opt() {"		
			+ "					{"
			+ "						parent = «genClass.ecoreClass.name»Impl.this;"
			+ "						childIndex = «localChildren.indexOf(child)»;"
			+ "						delegatee = new IAccessMethods() {"
			+ "							public ASTNode getChild() {"
			+ "								return (ASTNode)get«child.name.toFirstUpper()»();"
			+ "							}"
			+ "							public void setChild(ASTNode node) {"
			+ "								set«child.name.toFirstUpper()»((«child.eReferenceType.name»)node);"
			+ "								if (node != null)"
			+ "									node.childIndex = 0;"
			+ "							}"
			+ "					 	};"
			+ "					}"
			+ "				};"
			+ "			public ASTNode getChild() {"
			+ "				return opt;"
			+ "			}"
			+ "			public void setChild(ASTNode node) {"
			+ "				final Opt newOpt = (Opt)node;"
			+ "				opt = newOpt;"
			+ "				if (newOpt.getNumChildNoTransform() > 0)"
			+ "					set«child.name.toFirstUpper()»((«child.eReferenceType.name»)newOpt.getChildNoTransform(0));"
			+ "				else set«child.name.toFirstUpper()»(null);"
			+ "				newOpt.parent = «genClass.ecoreClass.name»Impl.this;"
			+ "				newOpt.childIndex = index;"
			+ "				newOpt.delegatee = new IAccessMethods() {"
			+ "					public ASTNode getChild() {"
			+ "						return (ASTNode)get«child.name.toFirstUpper()»();"
			+ "					}"
			+ "					public void setChild(ASTNode node) {"
			+ "						set«child.name.toFirstUpper()»((«child.eReferenceType.name»)node);"
			+ "						if (node != null)"
			+ "							node.childIndex = 0;"
			+ "					}"
			+ "				};"
			+ "			}"
«ELSE-»
«REM»
	The child is an ordinary non-terminal. There is no special treatment
	neccessary.
«ENDREM»
			+ "			public ASTNode getChild() {"
			+ "				return (ASTNode)get«child.name.toFirstUpper()»();"
			+ "			}"
			+ "			public void setChild(ASTNode node) {"
			+ "				set«child.name.toFirstUpper()»((«child.eReferenceType.name»)node);"
			+ "				if (node != null)"
			+ "					node.childIndex = index;"
			+ "			}"
«ENDIF-»
«ENDIF-»
			+ "		};"
			+ "		resolve_access_cache[index - «inheritedChildren.size»] = access;"
			+ "		return access;"
«ENDFOREACH-»
			+ "	default: return super.resolveAccess(index);"
			+ "	}")
	public IAccessMethods «genClass.ecoreClass.name».resolveAccess(final int index) {
		return null;
	}
	
«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDIF-»
«ENDFOREACH-»
«ENDFOREACH-»
	/* 
	 * Correct JastAdd's terminal access methods, i.e. force their regeneration
	 * by EMF, such that the model's access methods are used.
	 */
	
«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
«IF !genClass.ecoreClass.interface-»
«LET genClass.ecoreClass.eAttributes.select(e|!e.derived) AS localTerminals-»
«FOREACH localTerminals AS terminal-»
	/**
	 * <!--  -->
	 * @generated 
	 */
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public «terminal.eAttributeType.instanceTypeName!=null?terminal.eAttributeType.instanceTypeName:terminal.eAttributeType.name» «genClass.ecoreClass.name».get«terminal.name.toFirstUpper()»() {return null;}
	
	/**
	 * <!--  -->
	 * @generated 
	 */
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public void «genClass.ecoreClass.name».set«terminal.name.toFirstUpper()»(«terminal.eAttributeType.instanceTypeName!=null?terminal.eAttributeType.instanceTypeName:terminal.eAttributeType.name» value) {}
	
«ENDFOREACH-»
«ENDLET-»
«ENDIF-»
«ENDFOREACH-»
«ENDFOREACH-»

	/*
     *	Insert setters for imperative EMF attributes. This adds a required cast to the implementation type when setting the 
     *  new target and sets the attr_computed value to true. The rest should work as expected from the original EMF
     *  generated method. However, attributes with cardinality > 1 must be excluded since setting is done via list add.	
	 */
	 
«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
«IF !genClass.ecoreClass.interface-»
«LET genClass.ecoreClass.eReferences.select(e|!e.containment&&!e.many&&e.derived&&e.changeable) AS imperativeReferences-»
«FOREACH imperativeReferences AS imperativeReference-»
	@«outPackage».JastEMFAnnotations.MutatingMethod(
			  "public void set«imperativeReference.name.toFirstUpper()»(«imperativeReference.eType.name» new«imperativeReference.name.toFirstUpper()»){"
			+ "		«imperativeReference.eType.name» old«imperativeReference.name.toFirstUpper()» =  «imperativeReference.name»;"
			+ "		«imperativeReference.name» = «IF classifierInGenPackages(genPackages,imperativeReference.eType)-»
				(«imperativeReference.eType.name»Impl)new«imperativeReference.name.toFirstUpper()»;"
			«ELSE-» new«imperativeReference.name.toFirstUpper()»;"
			«ENDIF-»
			+ "		«imperativeReference.name»_computed = true;"
			+ "		if (eNotificationRequired())"
			+ "			eNotify(new ENotificationImpl(this, Notification.SET,"
			+ "				«genPackage.ecorePackage.name.toFirstUpper()»Package.«toUpperCaseUnderline(genClass.ecoreClass.name)»__«toUpperCaseUnderline(imperativeReference.name)», old«imperativeReference.name.toFirstUpper()», «imperativeReference.name»));"
			+ "}")
	public void «genClass.ecoreClass.name».set«imperativeReference.name.toFirstUpper()»_hook(«imperativeReference.eType.name» new«imperativeReference.name.toFirstUpper()»){
		return;
	}
«ENDFOREACH-»	
«ENDLET-»
«ENDIF-»
«ENDFOREACH-»
«ENDFOREACH-»

	/* 
	 * Insert hooks containing the implementation of metamodel operations which
	 * have a parameter or return type consisting of an AST node type. These
	 * implementations have to be woven into the evaluator after the AST node
	 * type refactorings have been executed, since the refactoring would change
	 * their signature. The implementation of such operations simply delegates
	 * to their -- since the refactorings type incompatible -- associated
	 * JastAdd attribute methods and performs appropriate type casts.
	 */

«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
«IF !genClass.ecoreClass.interface-»
«FOREACH genClass.genOperations AS genOperation-»
«LET genOperation.ecoreOperation AS operation-»
«IF operation.eType.eTypeParameters.size>0 || operation.many-»	
	@«outPackage».JastEMFAnnotations.MutatingMethod(
			  "public «getGenericTypeString(operation)» «genOperation.ecoreOperation.name»(«getParameterListString(operation)»){"
			+ "	return («getTypeString(operation)»)jastadd_«genOperation.ecoreOperation.name»(«getArgumentListString(operation)»);"
			+ "}")
	public «getTypeString(operation)» «genClass.ecoreClass.name».«genOperation.ecoreOperation.name»_hook(«getParameterListString(operation)»){
		return null;
	}
	
«ENDIF-» 
«ENDLET-»
«ENDFOREACH-»	
«ENDIF-»
«ENDFOREACH-»
«ENDFOREACH-»
	/* 
	 * Replace each AST node's "copy()" method generated by JastAdd with an
	 * implementation that is not anymore based on ASTNode's "children" array.
	 * Thus, the new implementation uses the model repository instead of
	 * JastAdd's repository.
	 */
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public ASTNode ASTNode.copy() {
		try {
			return (ASTNode) clone();
		} catch (CloneNotSupportedException e) {
		}
		System.err.println("Error: Could not clone node of type "
				+ getClass().getName() + "!");
		return null;
	}
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public List List.copy() {
		try {
			return (List) clone();
		} catch (CloneNotSupportedException e) {}
		System.err.println("Error: Could not clone node of type "
				+ getClass().getName() + "!");
		return null;
	}
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public Opt Opt.copy() {
		try {
			return (Opt) clone();
		} catch (CloneNotSupportedException e) {
		}
		System.err.println("Error: Could not clone node of type "
				+ getClass().getName() + "!");
		return null;
	}
	
«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
«IF !genClass.ecoreClass.interface-»
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public «genClass.ecoreClass.name» «genClass.ecoreClass.name».copy() {
		try {
			return («genClass.ecoreClass.name») clone();
		} catch (CloneNotSupportedException e) {}
		System.err.println("Error: Could not clone node of type "
				+ getClass().getName() + "!");
		return null;
	}
	
«ENDIF-»
«ENDFOREACH-»
«ENDFOREACH-»
	/* 
	 * Replace AST nodes' "getParent()" method with an implementation based on
	 * the model repository. Additionally, remove the "setParent" method, since
	 * child-parent relationships are automatically handled by the EMF. There
	 * is no need to set a parent.
	 */
	
	@«outPackage».JastEMFAnnotations.SuicideCopycat
	public void ASTNode.setParent(ASTNode node) {}
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public ASTNode ASTNode.getParent() {
		if (eContainer == null)
			return null;
		final ASTNode parent;
		EStructuralFeature feature = this.eContainingFeature();
		if (feature.isMany() || feature.getLowerBound() == 0) {
			parent = ((ASTNode) eContainer).resolveAccess(
					eContainer.eClass().getEAllContainments().indexOf(feature))
					.getChild();
		} else {
			parent = (ASTNode) eContainer;
		}
		if (parent.is$Final() != is$Final())
			state().boundariesCrossed++;
		return parent;
	}
	
	public ASTNode List.parent;
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public ASTNode List.getParent() {
		if (parent != null && parent.is$Final() != is$Final())
			state().boundariesCrossed++;
		return parent;
	}
	
	public ASTNode Opt.parent;
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public ASTNode Opt.getParent() {
		if (parent != null && parent.is$Final() != is$Final())
			state().boundariesCrossed++;
		return parent;
	}
	
«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
«IF !genClass.ecoreClass.interface-»
«LET genClass.ecoreClass.eReferences.select(e|e.containment) AS localChildren-»
«LET genClass.ecoreClass.eAllContainments.select(e|!localChildren.contains(e)) AS inheritedChildren-»
«IF localChildren.size > 0-»
«FOREACH localChildren AS child-»
«IF child.upperBound == -1-»
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public void «genClass.ecoreClass.name».add«child.name»(«child.eReferenceType.name» node) {
		ASTList list = (getParent() == null || state() == null)
				? get«child.name»ListNoTransform()
				: get«child.name»List();
		list.addChild(node);
	}
	
«ENDIF-»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDIF-»
«ENDFOREACH-»
«ENDFOREACH-»
	/* 
	 * Replace AST nodes' "numChild()" method to ease child count handling.
	 */
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	protected int ASTNode.numChildren() {
		return eClass().getEAllContainments().size();
	}
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	protected int List.numChildren() {
		return delegatee.size();
	}
	
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	protected int Opt.numChildren() {
		return delegatee.getChild() != null ? 1 : 0;
	}
}

«ENDFILE»
«ENDDEFINE»
