«REM»
	This program and the accompanying materials are made available under the
	terms of the BSD 3-clause license which accompanies this distribution.
«ENDREM»
«EXTENSION org::jastemf::aspects::io»
«EXTENSION org::jastemf::refactorings::refactorings»
«IMPORT ecore»
«IMPORT genmodel»

«REM»
	Template to generate a <i>JDT</i> refactoring script and support artifacts,
	to perform renamings of the generated <i>JastAdd</i> evaluator's classes
	and their methods and fields w.r.t. the given <i>EMF</i> generator model.
	@author S. Karol
«ENDREM»
«DEFINE Main(String astPackage, String outPackage) FOR GenModel»

«FILE asDirectory(outPackage) + "Refactorings.jrag"-»
/**
 * Generated by JastEMF [«timeStamp()»]
 */
«FOREACH genPackages AS genPackage-»
import «genPackage.ecorePackage()».*;
import «astPackage».*;
import «astPackage».List;
«IF genPackage.interfacePackageSuffix != null-»
import «qualifiedPackage(genPackage, genPackage.interfacePackageSuffix)».*;
«ENDIF-»
«IF genPackage.classPackageSuffix != null-»
import «qualifiedPackage(genPackage, genPackage.classPackageSuffix)».*;
«ENDIF-»
«ENDFOREACH-»

/**
 * Aspect, that prepares the generated <i>JastAdd</i> evaluator for its
 * decomposition w.r.t. the package structure of the given <i>EMF</i>
 * generator model.
 * @author C. Bürger
 */
aspect Refactorings {
	/*
	 * Correct JastAdd internal fields, such that they can be accessed
	 * by AST nodes across package boundaries.
	 */
	
	/* TODO JastAdd Bug: Annotierte Felder = Syntaxfehler
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public int ASTNode.numChildren = 0;
	@«outPackage».JastEMFAnnotations.CannibalicCopycat
	public int ASTNode.childIndex = -1;
	*/
}

«ENDFILE»

«FILE asDirectory(outPackage) + "Refactorings.xml"-»
<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by JastEMF [«timeStamp()»] -->
<session version="1.0">

<!-- 
	Rename JastAdd's List type to avoid name clashes with 'java.util.List'
	(If 'java.util.List' types are used in the metamodel such clashes result)
-->

<refactoring
	comment="Rename &apos;List&apos;"
	description="Rename &apos;List&apos;"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.type"
	input="«this.computeCompilationUnitPath("List",astPackage)»"
	matchStrategy="1"  
	name="ASTList"
	project="«this.computeProjectName()»"
	qualified="false"
	references="true"
	similarDeclarations="false"
	textual="false"
	version="1.0"/>

<!--
	Rename each JastAdd AST access method to prevent a name clash with its
	associated EMF containment element access method. Additionally, rename
	JastAdd attribute methods that represent derived attributes or
	non-containment references w.r.t. EMF naming schemes (e.g. "get"
	prefixes for ordinary attributes and "is" prefixes for attributes returning
	a boolean value). Furthermore, rename JastAdd attribute methods that
	represent metamodel operations iff one of their parameter types or their
	return type consist of an AST node type (e.g. as part of a generic type
	parameter). That is neccessary, since refactorings will change this type to
	its concrete EMF implementation and consequently the refactored JastAdd
	attribute method is not type-compatible with its associated metamodel
	declaration.
-->
«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»

<!-- Rename methods of «genClass.ecoreClass.name» -->

«EXPAND ExpandAccessMethodsRenamings(genClass, astPackage) FOREACH genClass.genFeatures.ecoreFeature-»
«EXPAND ExpandAccessMethodsRenamings(genClass, astPackage) FOREACH genClass.genOperations.ecoreOperation-»
«ENDFOREACH-»
«ENDFOREACH-»

<!--
	Rename each JastAdd AST class w.r.t. the EMF generator model's class name
	pattern.
-->

«FOREACH genPackages AS genPackage-»
«FOREACH genPackage.genClasses AS genClass-»
<refactoring
	comment="Rename &apos;«genClass.ecoreClass.name»&apos;"
	description="Rename &apos;«genClass.ecoreClass.name»&apos;"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.type"
	input="«genClass.computeCompilationUnitPath(astPackage)»"
	matchStrategy="1"  
	name="«genClass.ecoreClass.name»Impl"
	project="«genClass.computeProjectName()»"
	qualified="false"
	references="true"
	similarDeclarations="false"
	textual="false"
	version="1.0"/>
«ENDFOREACH-»
«ENDFOREACH-»

<!--
	Move each JastAdd class to its package specified in the EMF generator
	model.
-->

«FOREACH genPackages AS genPackage-»
«LET genPackage.genClasses.select(e|!e.ecoreClass.interface) AS toMove-»
«IF !toMove.isEmpty-»«REM»

	BUG: The following uncommented solution does not work because of a JDK Bug
		in the SAX XML parsing API, which results in erroneous parses of XML
		nodes' attributes if a node has many attributes. Consequently, the
		generated refactoring script would be incorrect parsed. For details
		see:
			https://bugs.eclipse.org/bugs/show_bug.cgi?id=262820
			http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6690015
	WORKAROUND: Instead of one refactoring moving all classes at once we move
		the classes stepwise. Of course, that is much less performant.

<refactoring
	comment="Move JastAdd classes for package '«genPackage.ecorePackage.name»'"
	description="Move JastAdd classes for package '«genPackage.ecorePackage.name»'"
	destination="«toMove.get(0).computePackagePath((genPackage.basePackage != null ? genPackage.basePackage + "." : "") + genPackage.ecorePackage.name)»«genPackage.classPackageSuffix != null ? "." + genPackage.classPackageSuffix : ""»"
«FOREACH toMove AS genClass-»
	element«toMove.indexOf(genClass) + 1»="«genClass.computeClassPath(astPackage)»«classNamePattern != null ? classNamePattern : "Impl"».java"
«ENDFOREACH-»
	files="0"
	flags="589830"
	folders="0"
	id="org.eclipse.jdt.ui.move"
	patterns="*"
	policy="org.eclipse.jdt.ui.moveResources"
	project="«toMove.get(0).computeProjectName()»"
	qualified="false"
	references="true"
	units="«toMove.size»"
	version="1.0"/>
	
«ENDREM-»
«FOREACH toMove AS genClass-»
«LET (genPackage.basePackage != null ? genPackage.basePackage + "." : "") + genPackage.ecorePackage.name + (genPackage.classPackageSuffix != null ? "." + genPackage.classPackageSuffix : "") AS destPackage-»
<refactoring
	comment="Move '«genClass.ecoreClass.name»' to package '«destPackage»'"
	description="Move '«genClass.ecoreClass.name»' to package '«destPackage»'"
	destination="«genClass.computePackagePath(destPackage)»"
	element1="«genClass.computeClassPath(astPackage)»«classNamePattern != null ? classNamePattern : "Impl"».java"
	files="0"
	flags="589830"
	folders="0"
	id="org.eclipse.jdt.ui.move"
	patterns="*"
	policy="org.eclipse.jdt.ui.moveResources"
	project="«genClass.computeProjectName()»"
	qualified="false"
	references="true"
	units="1"
	version="1.0"/>
«ENDLET-»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»

</session>
«ENDFILE»

«ENDDEFINE»

«REM»
The following renames accessor methods for attributes in JastAdd to match with the derived EAttributes accessors
in ECore. 
Case 1: Consider a String attribute 'name' in JastAdd. The generated accessor will be 'name()'. 
In contrast, the EMF always generates camel case getters for EAttributes, i.e., the EMF generates 'getName()'
as accessor method (if 'name' was a boolean attribute, it would generate 'isName()').
Case 2: Consider a String terminal 'name' in JastAdd. The generated accessor will be 'getname()'. 
The EMF will generate the same camel case accessors as mentioned above. Hence, we also have to 
rename the accessors for terminals (= non derived EAttributes). 
«ENDREM»
«DEFINE ExpandAccessMethodsRenamings(GenClass genClass, String astPackage) FOR EAttribute-»
«IF "EBoolean" == (this.eType.name) && !this.many-»
<refactoring 
	comment="Rename method &apos;«this.derived?"":"get"»«this.name»&apos;"
	delegate="false"
	deprecate="true"
	description="Rename accessor for «this.derived?"attribute":"terminal"» &apos;«this.name»&apos;"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.method"
	input="«genClass.computeCompilationUnitPath(astPackage)»~«this.derived?"":"get"»«this.name»"
	name="is«this.name.toFirstUpper()»"
	project="«genClass.computeProjectName()»"
	references="true"
	version="1.0"/>
«ELSE-» 
<refactoring 
	comment="Rename method &apos;«this.derived?"":"get"»«this.name»&apos;"
	delegate="false"
	deprecate="true"
	description="Rename accessor for «this.derived?"attribute":"terminal"» &apos;«this.name»&apos;"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.method"
	input="«genClass.computeCompilationUnitPath(astPackage)»~«this.derived?"":"get"»«this.name»"
	name="get«this.name.toFirstUpper()»"
	project="«genClass.computeProjectName()»"
	references="true"
	version="1.0"/>
«ENDIF-»
«ENDDEFINE»

«REM»
The following renames JastAdd attributes and terminals that correspond to EReferences in the metamodel.
Case 1: For non-containments, an attribute accessor 'acc()' has to be renamed to the corresponding accessor 
'getAcc()' in the code generated by the EMF.
Case 2: For containment terminals with upper bound = 1, we rename the JastAdd specific accessors with the prefix 'jastadd_get' 
to ensure that 1., The EMF methods are inserted appropriately when merging the classes (i.e., 'getAcc()' will be 
implemented by generated EMF code and will have the Interface type as return type) and 2., to still have the 
original jastadd getters available which have the implementation class as return type. Note that the jastadd 
getters still use getChild(int i) to obtain the actual child node.
(Case 3: We do not need to handle containment terminals with unbounded lists because name clashes with 
getters do not occur, because for a terminal 'acc' JastAdd generates 'getaccList()', 'getaccListNoTransform()', getacc(int i),
'getaccs()', 'getaccNoTransform()' while the EMF only generates 'getAcc()'.) 
«ENDREM»
«DEFINE ExpandAccessMethodsRenamings(GenClass genClass, String astPackage) FOR EReference-»
«IF !this.containment-»
<refactoring 
	comment="Rename method &apos;«this.name»&apos;"
	delegate="false"
	deprecate="true"
	description="Rename accessor for attribute &apos;«this.name»&apos; which is a non-containment in the metamodel"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.method"
	input="«genClass.computeCompilationUnitPath(astPackage)»~«this.name»"
	name="get«this.name.toFirstUpper()»"
	project="«genClass.computeProjectName()»"
	references="true"
	version="1.0"/>
«ELSE-»
«IF !this.many-»
<refactoring
	comment="Rename method &apos;get«this.name»()&apos;"
	delegate="false"
	deprecate="true"
	description="Rename accessor for terminal &apos;«this.name»()&apos; which is a containment in the metamodel"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.method"
	input="«genClass.computeCompilationUnitPath(astPackage)»~get«this.name»"
	name="jastadd_get«this.name.toFirstUpper()»"
	project="«genClass.computeProjectName()»"
	references="true"
	version="1.0"/>
<refactoring
	comment="Rename method &apos;set«this.name»(«this.eReferenceType.name» node)&apos;"
	delegate="false"
	deprecate="false"
	description="Rename setter for &apos;«this.name.toFirstUpper()»(«this.eReferenceType.name» node)&apos;"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.method"
	input="«genClass.computeCompilationUnitPath(astPackage)»~set«this.name»~Q«this.eReferenceType.name»;"
	name="jastadd_set«this.name.toFirstUpper()»"
	project="«genClass.computeProjectName()»"
	references="true"
	version="1.0"/>
«ENDIF-»
«ENDIF-»
«ENDDEFINE»

«DEFINE ExpandAccessMethodsRenamings(GenClass genClass, String astPackage) FOR EOperation-»
«IF this.eType.eTypeParameters.size > 0 || this.many-»
<refactoring
	comment="Rename method &apos;«this.name»()&apos;"
	delegate="false"
	deprecate="true"
	description="Rename method &apos;«this.name»()&apos;"
	flags="589830"
	id="org.eclipse.jdt.ui.rename.method"
	input="«genClass.computeCompilationUnitPath(astPackage)»~«this.name-»«FOREACH this.eParameters AS parameter-»~«getRefactoringTypeString(parameter)»«ENDFOREACH-»"
	name="jastadd_«this.name»"
	project="«genClass.computeProjectName()»"
	references="true"
	version="1.0"/>
«ENDIF-»
«ENDDEFINE»

«DEFINE ExpandAccessMethodsRenamings(GenClass genClass, String astPackage) FOR EStructuralFeature-»
«REM»
Default: do nothing
«ENDREM-»
«ENDDEFINE»
