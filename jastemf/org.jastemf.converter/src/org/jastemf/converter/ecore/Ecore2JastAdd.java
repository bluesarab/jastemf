package org.jastemf.converter.ecore;

import java.util.Calendar;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Queue;

import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.jastemf.util.XTendUtil;

/**
 * This class provides a mapping from Ecore to JastAdd2.
 * 
 * @author sven.karol
 */
public class Ecore2JastAdd {
	

	/**
	 * Converts a given GenModel and all of its contained subpackages to a
	 * collection of JastAdd Jrag specifications.
	 * 
	 * @param root
	 *            The root GenModel.
	 * @return The list of corresponding Jrag specifications.
	 */
	public static Collection<JastAddSpec> convertPackages2Jrag(GenModel root) {
		Collection<JastAddSpec> specs = new LinkedList<JastAddSpec>();
		for(GenPackage pck:root.getGenPackages()){
			specs.addAll(convertPackages2Jrag(pck));
		}
		return specs;
	}
	
	/**
	 * Converts a given GenPackage and all of its contained subpackages to a
	 * collection of JastAdd Jrag specifications.
	 * 
	 * @param root
	 *            The root package.
	 * @return The list of corresponding Jrag specifications.
	 */
	public static Collection<JastAddSpec> convertPackages2Jrag(GenPackage root) {
		Collection<JastAddSpec> specs = new LinkedList<JastAddSpec>();
		Queue<GenPackage> packages = new LinkedList<GenPackage>();
		packages.add(root);
		while (!packages.isEmpty()) {
			GenPackage current = packages.poll();
			String resourceName = current.getPackageName() + ".jrag";
			if (current.getBasePackage() != null
					&& !current.getBasePackage().isEmpty()) {
				resourceName = current.getBasePackage() + "." + resourceName;
			}
			JastAddSpec spec = new JastAddSpec(resourceName,
					convertPackage2Jrag(current.getEcorePackage()));
			specs.add(spec);
			packages.addAll(current.getSubGenPackages());
		}

		return specs;
	}

	/**
	 * Converts a given GenModel and all of its contained subpackages to a
	 * collection of JastAdd AST specifications.
	 * 
	 * @param root
	 *            The root GenModel.
	 * @return The list of corresponding AST specifications.
	 */
	public static Collection<JastAddSpec> convertPackages2AST(GenModel root) {
		Collection<JastAddSpec> specs = new LinkedList<JastAddSpec>();
		for(GenPackage pck:root.getGenPackages()){
			specs.addAll(convertPackages2AST(pck));
		}
		return specs;
	}
	
	
	/**
	 * Converts a given GenPackage and all of its contained subpackages to a
	 * collection of JastAdd AST specifications.
	 * 
	 * @param root
	 *            The root GenPackage.
	 * @return The list of corresponding AST specifications.
	 */
	public static Collection<JastAddSpec> convertPackages2AST(GenPackage root) {
		Collection<JastAddSpec> specs = new LinkedList<JastAddSpec>();
		Queue<GenPackage> packages = new LinkedList<GenPackage>();
		packages.add(root);
		while (!packages.isEmpty()) {
			GenPackage current = packages.poll();
			String resourceName = current.getPackageName() + ".ast";
			if (current.getBasePackage() != null
					&& !current.getBasePackage().isEmpty()) {
				resourceName = current.getBasePackage() + "." + resourceName;
			}
			JastAddSpec spec = new JastAddSpec(resourceName,
					convertPackage2AST(current.getEcorePackage()));
			specs.add(spec);
			packages.addAll(current.getSubGenPackages());
		}

		return specs;
	}

	/**
	 * Given an Ecore EPackage, this method generates a corresponding JastAdd
	 * AST specification.
	 * 
	 * @param pck
	 *            The Ecore EPackage.
	 * @return The String that contains the AST specification.
	 */
	public static String convertPackage2AST(EPackage pck) {
		StringBuffer out = new StringBuffer();
		String val = ("/** %n" + "* Spanning tree for ecore package %2$s. %n"
				+ " * %n"
				+ " * Generated by JastEMF [%1$tb %1$td %1$tT %1$tZ %1$tY] %n"
				+ " */ %n");
		out.append(String.format(val, Calendar.getInstance(), pck.getName()));

		for (EClassifier classifier : pck.getEClassifiers()) {
			if (classifier instanceof EClass) {
				EClass eClass = (EClass) classifier;
				if (eClass.isAbstract()) {
					out.append("abstract ");
				}
				out.append(eClass.getName());
				if (!eClass.getESuperTypes().isEmpty()) {
					// JastAdd supports single inheritance only
					out.append(":" + eClass.getESuperTypes().get(0).getName());
				}
				boolean defPrefix = true; // needed 1x per AST type
				for (EAttribute eAtt : eClass.getEAttributes()) {
					// the AST considers non-derived features only
					if (!eAtt.isDerived()) {
						if (defPrefix) {
							out.append(" ::=");
							defPrefix = false;
						}
						val = " <%1$s:%2$s>";
						String typeName = EEnum.class.isInstance(eAtt
								.getEType()) ? eAtt.getEType().getName()
								: XTendUtil.getSimpleInstanceTypeName(eAtt
										.getEType());
						out.append(String.format(val, eAtt.getName(), typeName));
					}
				}

				for (EReference eRef : eClass.getEReferences()) {
					// the AST considers containment references and
					// containment-based NTA's only
					if (eRef.isContainment()) {
						if (defPrefix) {
							out.append(" ::=");
							defPrefix = false;
						}
						String typeName = eRef.getEReferenceType().getName()
								.equals("EObject") ? "ASTNode" : eRef
								.getEReferenceType().getName();
						String refName = eRef.getName();
						// For now, we consider EStringToStringMapEntry as a
						// terminal type.
						if (eRef.getName().equals("EStringToStringMapEntry"))
							val = " <%1$s:%2$s>";
						else if (eRef.getLowerBound() == 0
								&& (eRef.getUpperBound() == 1 || eRef
										.getUpperBound() == -2)) {
							// optionals
							val = eRef.isDerived() ? " /[%1$s:%2$s]/" : " [%1$s:%2$s]";
						} else if (eRef.getLowerBound() == 1
								&& eRef.getUpperBound() == 1) {
							// regular children
							val = eRef.isDerived() ? " /%1$s:%2$s/" : " %1$s:%2$s";
						} else if (eRef.getUpperBound() > 1
								|| eRef.getUpperBound() == -1) {
							// list children
							val = eRef.isDerived() ? " /%1$s:%2$s*/" : " %1$s:%2$s*";
						}
						out.append(String.format(val,refName,typeName));
					}
				}

				out.append(String.format(";%n"));
			}
		}
		return out.toString();
	}

	/**
	 * Given an Ecore EPackage, this methods generates a corresponding JastAdd2
	 * JRAG specification. Currently, this specification only considers
	 * non-containment EReferences and derived EAttributes, and only generates
	 * stub attribute declarations.
	 * 
	 * @param pck
	 *            The input EPackage.
	 * @return The String that contains the basic attribute declarations.
	 */
	public static String convertPackage2Jrag(EPackage pck) {
		StringBuffer out = new StringBuffer();
		String val = ("/** %n"
				+ " * Generated attribution skeleton for ecore package %2$s.%3$s. %n"
				+ " * %n"
				+ " * Generated by JastEMF [%1$tb %1$td %1$tT %1$tZ %1$tY] %n"
				+ " */ %n");
		out.append(String.format(val, Calendar.getInstance(),
				pck.getNsPrefix(), pck.getName()));
		out.append(String.format("aspect Core {%n"));
		for (EClassifier classifier : pck.getEClassifiers()) {
			if (classifier instanceof EClass) {
				EClass eClass = (EClass) classifier;
				for (EReference eRef : eClass.getEReferences()) {
					if (!eRef.isContainment()) {
						val = "inh %1$s %2$s.%3$s();%n";
						out.append(String.format("// definition for EReference, please redefine if you need syn attributes %n"));
						out.append(String.format(val, eRef.getEReferenceType()
								.getName(), eRef.getEContainingClass()
								.getName(), eRef.getName()));
					}
				}
				for (EAttribute eAtt : eClass.getEAttributes()) {
					if (eAtt.isDerived()) {
						val = "syn %1$s %2$s.%3$s; %n";
						out.append(String.format("// definition for derived EAttribute %n"));
						out.append(String.format(val,
								eAtt.getEType().getName(), eAtt
										.getEContainingClass().getName(), eAtt
										.getName()));
					}
				}
			}
		}
		out.append("}");
		return out.toString();
	}

}
